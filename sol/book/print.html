<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust By Practice</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Learn Rust with Example, Exercise and real Practice, written with ❤️ by https://course.rs team">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/style1.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');
                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }
                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">- Rust By Practice</li><li class="chapter-item expanded affix "><li class="part-title">- Small projects with Elegant code</li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">1.</strong> Variables</a></li><li class="chapter-item expanded "><a href="basic-types/intro.html"><strong aria-hidden="true">2.</strong> Basic Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-types/numbers.html"><strong aria-hidden="true">2.1.</strong> Numbers</a></li><li class="chapter-item "><a href="basic-types/char-bool-unit.html"><strong aria-hidden="true">2.2.</strong> Char, Bool and Unit</a></li><li class="chapter-item "><a href="basic-types/statements-expressions.html"><strong aria-hidden="true">2.3.</strong> Statements and Expressions</a></li><li class="chapter-item "><a href="basic-types/functions.html"><strong aria-hidden="true">2.4.</strong> Functions</a></li></ol></li><li class="chapter-item expanded "><a href="ownership/intro.html"><strong aria-hidden="true">3.</strong> Ownership and Borrowing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ownership/ownership.html"><strong aria-hidden="true">3.1.</strong> Ownership</a></li><li class="chapter-item "><a href="ownership/borrowing.html"><strong aria-hidden="true">3.2.</strong> Reference and Borrowing</a></li></ol></li><li class="chapter-item expanded "><a href="compound-types/intro.html"><strong aria-hidden="true">4.</strong> Compound Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compound-types/string.html"><strong aria-hidden="true">4.1.</strong> string</a></li><li class="chapter-item "><a href="compound-types/array.html"><strong aria-hidden="true">4.2.</strong> Array</a></li><li class="chapter-item "><a href="compound-types/slice.html"><strong aria-hidden="true">4.3.</strong> Slice</a></li><li class="chapter-item "><a href="compound-types/tuple.html"><strong aria-hidden="true">4.4.</strong> Tuple</a></li><li class="chapter-item "><a href="compound-types/struct.html"><strong aria-hidden="true">4.5.</strong> Struct</a></li><li class="chapter-item "><a href="compound-types/enum.html"><strong aria-hidden="true">4.6.</strong> Enum</a></li></ol></li><li class="chapter-item expanded "><a href="flow-control.html"><strong aria-hidden="true">5.</strong> Flow Control</a></li><li class="chapter-item expanded "><a href="pattern-match/intro.html"><strong aria-hidden="true">6.</strong> Pattern Match</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pattern-match/match-iflet.html"><strong aria-hidden="true">6.1.</strong> match, matches! and if let</a></li><li class="chapter-item "><a href="pattern-match/patterns.html"><strong aria-hidden="true">6.2.</strong> Patterns</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">- Method & Associated function</li><li class="chapter-item expanded affix "><li class="part-title">- Generics and Traits</li><li class="chapter-item expanded affix "><li class="part-title">- Generics</li><li class="chapter-item expanded affix "><li class="part-title">- Const Generics</li><li class="chapter-item expanded affix "><li class="part-title">- Traits</li><li class="chapter-item expanded affix "><li class="part-title">- Trait Object</li><li class="chapter-item expanded affix "><li class="part-title">- Advanced Traits</li><li class="chapter-item expanded affix "><li class="part-title">- Collection Types</li><li class="chapter-item expanded affix "><li class="part-title">- String</li><li class="chapter-item expanded affix "><li class="part-title">- Vector</li><li class="chapter-item expanded affix "><li class="part-title">- HashMap</li><li class="chapter-item expanded affix "><li class="part-title">- Type Conversion</li><li class="chapter-item expanded affix "><li class="part-title">- as</li><li class="chapter-item expanded affix "><li class="part-title">- From/Into</li><li class="chapter-item expanded affix "><li class="part-title">- Others</li><li class="chapter-item expanded affix "><li class="part-title">- Result and panic</li><li class="chapter-item expanded affix "><li class="part-title">- panic!</li><li class="chapter-item expanded affix "><li class="part-title">- Result and ?</li><li class="chapter-item expanded affix "><li class="part-title">- Crate and Module</li><li class="chapter-item expanded affix "><li class="part-title">- Package and Crate</li><li class="chapter-item expanded affix "><li class="part-title">- Module</li><li class="chapter-item expanded affix "><li class="part-title">- Advanced use and pub</li><li class="chapter-item expanded affix "><li class="part-title">- Comments and Docs</li><li class="chapter-item expanded affix "><li class="part-title">- Formatted output</li><li class="chapter-item expanded affix "><li class="part-title">- println! and format!</li><li class="chapter-item expanded affix "><li class="part-title">- Debug and Display</li><li class="chapter-item expanded affix "><li class="part-title">- formating</li><li class="chapter-item expanded affix "><li class="part-title">- Lifetime</li><li class="chapter-item expanded affix "><li class="part-title">- basic</li><li class="chapter-item expanded affix "><li class="part-title">- &'static and T: 'static</li><li class="chapter-item expanded affix "><li class="part-title">- advanced</li><li class="chapter-item expanded affix "><li class="part-title">- Functional programing</li><li class="chapter-item expanded affix "><li class="part-title">- Closure</li><li class="chapter-item expanded affix "><li class="part-title">- Iterator</li><li class="chapter-item expanded affix "><li class="part-title">- newtype and DST</li><li class="chapter-item expanded affix "><li class="part-title">- Smart pointers TODO</li><li class="chapter-item expanded affix "><li class="part-title">- Box</li><li class="chapter-item expanded affix "><li class="part-title">- Deref</li><li class="chapter-item expanded affix "><li class="part-title">- Drop</li><li class="chapter-item expanded affix "><li class="part-title">- Rc and Arc</li><li class="chapter-item expanded affix "><li class="part-title">- Cell and RefCell</li><li class="chapter-item expanded affix "><li class="part-title">- Weak and Circle reference TODO</li><li class="chapter-item expanded affix "><li class="part-title">- Self referential TODO</li><li class="chapter-item expanded affix "><li class="part-title">- Threads TODO</li><li class="chapter-item expanded affix "><li class="part-title">- Basic using</li><li class="chapter-item expanded affix "><li class="part-title">- Message passing</li><li class="chapter-item expanded affix "><li class="part-title">- Sync</li><li class="chapter-item expanded affix "><li class="part-title">- Atomic</li><li class="chapter-item expanded affix "><li class="part-title">- Send and Sync</li><li class="chapter-item expanded affix "><li class="part-title">- Global variables TODO</li><li class="chapter-item expanded affix "><li class="part-title">- Errors TODO</li><li class="chapter-item expanded affix "><li class="part-title">- Unsafe doing</li><li class="chapter-item expanded affix "><li class="part-title">- Inline assembly</li><li class="chapter-item expanded affix "><li class="part-title">- Macro TODO</li><li class="chapter-item expanded affix "><li class="part-title">- Tests TODO</li><li class="chapter-item expanded affix "><li class="part-title">- Write Tests</li><li class="chapter-item expanded affix "><li class="part-title">- Benchmark</li><li class="chapter-item expanded affix "><li class="part-title">- Unit and Integration</li><li class="chapter-item expanded affix "><li class="part-title">- Assertions</li><li class="chapter-item expanded affix "><li class="part-title">- Async/Await TODO</li><li class="chapter-item expanded affix "><li class="part-title">- async and await!</li><li class="chapter-item expanded affix "><li class="part-title">- Future</li><li class="chapter-item expanded affix "><li class="part-title">- Pin and Unpin</li><li class="chapter-item expanded affix "><li class="part-title">- Stream</li><li class="chapter-item expanded affix "><li class="part-title"></li><li class="chapter-item expanded affix "><li class="part-title">- Standard Library TODO</li><li class="chapter-item expanded affix "><li class="part-title">- String</li><li class="chapter-item expanded affix "><li class="part-title"></li><li class="chapter-item expanded affix "><li class="part-title">- Fighting with Compiler</li><li class="chapter-item expanded affix "><li class="part-title">- Borrowing</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust By Practice</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sunface/rust-by-practice" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<h3 id="binding-and-mutability"><a class="header" href="#binding-and-mutability">Binding and mutability</a></h3>
<ol>
<li>🌟 A variable can be used only if it has been initialized.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Fix the error below with least amount of modification to the code
fn main() {
    let x: i32 = 5; // Uninitialized but used, ERROR !

//Every variable must be initialized before using. duh... 

    let _y: i32; // Uninitialized but also unused, only a Warning !

// The convention is to add '_' before identifiers if you are not going to use them

    assert_eq!(x, 5);
    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="2">
<li>🌟 Use <code>mut</code> to mark a variable as mutable.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// Fill the blanks in the code to make it compile
fn main() {
    let mut x = 1;
    x += 2; 

// Variables are immutable by default
    
    assert_eq!(x, 3);
    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="scope"><a class="header" href="#scope">Scope</a></h3>
<p>A scope is the range within the program for which the item is valid.</p>
<ol start="3">
<li>🌟 </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Fix the error below with least amount of modification
fn main() {
    let x: i32 = 10;
//  {

    let y: i32 = 5;
    println!(&quot;The value of x is {} and value of y is {}&quot;, x, y);
    
//  } if braces were enabled then the variable 'y' will be destroyed here 

// Easiest way would be to change the scope of the variable.

    println!(&quot;The value of x is {} and value of y is {}&quot;, x, y); 
}
</code></pre></pre>
<ol start="4">
<li>🌟🌟 </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Fix the error with the use of define_x
fn main() {
// add function call to &quot;define_x&quot;
    println!(&quot;{}, world&quot;, define_x()); 
}

// Here &quot;'a&quot; is the lifetime parameter defined for the string that is returned
// This helps rust to identify the lifetime of a string variable so that the 
// compiler can safely destroy the string after it's lifetime is completed.
// In this example the lifetime &quot;'a&quot; is bound to the function call &quot;define_x&quot;
// after the function call, the string will be destroyed.

fn define_x&lt;'a&gt;() -&gt; &amp;'a str {
// Returning &amp;str
    &quot;hello&quot;
}
</code></pre></pre>
<h3 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h3>
<p>You can declare a new variable with the same name as a previous variable, here we can say **the first one is shadowed by the second one.</p>
<ol start="5">
<li>🌟🌟 </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Only modify `assert_eq!` to make the `println!` work(print `42` in terminal)
fn main() {
    let x: i32 = 5;
    {
// Here the variable x holds the value &quot;12&quot; in this scope
        let x = 12;
        assert_eq!(x, 12);
    }

// Here the value is &quot;5&quot; in this scope
    assert_eq!(x, 5);

    let x = 42;
    println!(&quot;{}&quot;, x); // Prints &quot;42&quot;.
}
</code></pre></pre>
<ol start="6">
<li>🌟🌟 </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Remove a line in the code to make it compile
fn main() {
    let mut _x: i32 = 1;
    _x = 7;
    // Shadowing and re-binding
    {
    // Shadowing must be done in a new scope
    let mut _x = _x; // add &quot;mut&quot; if you're going to mutate
    _x += 3;
    
    }

    let _y = 4;
    // Shadowing
    {
    
    let _y = &quot;I can also be bound to text!&quot;; 
    
    }
    
    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="unused-variables"><a class="header" href="#unused-variables">Unused variables</a></h3>
<ol>
<li>Fix the warning below with :</li>
</ol>
<ul>
<li>🌟  Only one solution</li>
<li>🌟🌟  Two distinct solutions</li>
</ul>
<blockquote>
<p>Note: none of the solutions is to remove the line <code>let x = 1</code> </p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[allow(unused_variables)] // 1) Allow unused variable
fn main() {
    let _x = 1; // 2) The convention is to add &quot;_&quot; before an unused variable 
}

// Warning: unused variable: `x`
</code></pre></pre>
<h3 id="destructuring"><a class="header" href="#destructuring">Destructuring</a></h3>
<ol start="8">
<li>🌟🌟 We can use a pattern with <code>let</code> to destructure a tuple to separate variables.</li>
</ol>
<blockquote>
<p>Tips: you can use Shadowing or Mutability</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Fix the error below with least amount of modification
fn main() {
    let (mut x, y) = (1, 2);
    x += 2;

// Make 'x' mutable

    assert_eq!(x, 3);
    assert_eq!(y, 2);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="destructuring-assignments"><a class="header" href="#destructuring-assignments">Destructuring assignments</a></h3>
<p>Introduced in Rust 1.59: You can now use tuple, slice, and struct patterns as the left-hand side of an assignment.</p>
<ol start="9">
<li>🌟🌟</li>
</ol>
<blockquote>
<p>Note: the feature <code>Destructuring assignments</code> need 1.59 or higher Rust version</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let (x, y);
    (x,..) = (3, 4);// 3 is assigned to x
    [.., y] = [1, 2];// 2 is assigned to y
// (x,...) is checked with (3, 4)

    assert_eq!([x,y], [3, 2]);

    println!(&quot;Success!&quot;);
} 
</code></pre></pre>
<pre><code class="language-ignore">    ----------
   |          |
   |    ---------
   |   |      |  |
   |   |      v  v
  (x, ...) = (3, 4); The &quot;...&quot; is ignored.

 Similarly,

    ---------
   |         |
   |    --------
   |   |     |  |
   |   |     v  v 
 [..., y] = [1, 2];

Hence, x = 3 and y = 2

</code></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-types"><a class="header" href="#basic-types">Basic Types</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch03-02-data-types.html">Rust Book 3.2 and 3.3</a></li>
<li>简体中文: <a href="https://course.rs/basic/base-type/index.html">Rust语言圣经 - 基本类型</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numbers"><a class="header" href="#numbers">Numbers</a></h1>
<h3 id="integer"><a class="header" href="#integer">Integer</a></h3>
<ol>
<li>🌟 </li>
</ol>
<blockquote>
<p>Tips: If we don't explicitly assign a type to a variable, then the compiler will infer one for us.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Remove something to make it work
fn main() {
    let x: i32 = 5;
    let mut y: i32 = 5; // make U32 to I32 so that the types of x and y can match

    y = x;
    
    let z = 10; // any unconstrained integer will default to type {Integer} which is i32.

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="2">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">//  Fill the blank
fn main() {
    let v: u16 = 38_u8 as u16; // &quot;as&quot; keyword is used for explicit type conversion

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="3">
<li>🌟🌟🌟</li>
</ol>
<blockquote>
<p>Tips: If we don't explicitly assign a type to a variable, then the compiler will infer one for us.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Modify `assert_eq!` to make it work
fn main() {
    let x = 5;
    assert_eq!(&quot;i32&quot;.to_string(), type_of(&amp;x)); // Integer is defaulted to i32 when type is not assigned explicitly.

    println!(&quot;Success!&quot;);
}

// Get the type of given variable, return a string representation of the type  , e.g &quot;i8&quot;, &quot;u8&quot;, &quot;i32&quot;, &quot;u32&quot;
fn type_of&lt;T&gt;(_: &amp;T) -&gt; String {
    format!(&quot;{}&quot;, std::any::type_name::&lt;T&gt;())
}
</code></pre></pre>
<ol start="4">
<li>🌟🌟 </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Fill the blanks to make it work
fn main() {
    assert_eq!(i8::MAX, 127); // The range is from -128 to 127 
    assert_eq!(u8::MAX, 255); // The range is from 0 to 255

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="5">
<li>🌟🌟 </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Fix errors and panics to make it work
fn main() {
   let v1 = 251_u16 + 8; // converting to u16 to increase the range
   if let Some(v2) = u8::checked_add(251, 8) {
       println!(&quot;{},{}&quot;,v1,v2);
   } else {
       println!(&quot;The sum will be out of range of \'u8\'.\nHence we cannot add \'8\' to it.&quot;);
   }
}
</code></pre></pre>
<ol start="6">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Modify `assert!` to make it work
fn main() {
    let v = 1_024 /* decimal 1024 */ + 0xff /* hexa decimal 255*/ + 0o77 /* octal 63 */ + 0b1111_1111 /* binary 255 */;
    
    assert!(v == 1597);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="floating-point"><a class="header" href="#floating-point">Floating-Point</a></h3>
<ol start="7">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">//  Replace ? with your answer
fn main() {
    let x = 1_000.000_1 // f64 is default
    let y: f32 = 0.12; // f32
    let z = 0.01_f64; // f64 

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol>
<li>🌟🌟 Make it work in two distinct ways</li>
</ol>
<p>I remember seeing this <a href="https://www.youtube.com/shorts/s9F8pu5KfyM">video</a> on YouTube that explained why computers suck at math because of rounding error.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 1) Using rounding function.

fn main() {
    
    assert!(0.1_f32.round() + 0.2_f32.round() == 0.3_f32.round());

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 2) Using absolute values

fn main() {
    
    assert!(0.1_f32.abs() + 0.2_f32.abs() == 0.3_f32.abs());

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="range"><a class="header" href="#range">Range</a></h3>
<ol start="9">
<li>🌟🌟 Two goals: 1. Modify <code>assert!</code> to make it work 2. Make <code>println!</code> output: 97 - 122</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut sum = 0;
    for i in -3..2 {
        sum += i
    }

    assert!(sum == -5); // Refer below

    for c in 'a'..='z' {
        println!(&quot;{}&quot;,c as u8); // explicit conversion to u8
    }
}
</code></pre></pre>
<table><thead><tr><th>Iter</th><th>Variables</th><th>Computation</th></tr></thead><tbody>
<tr><td>iter1</td><td>i =	-3	sum =	00</td><td>0 + (-3)</td></tr>
<tr><td>iter2</td><td>i =	-2	sum =	-3</td><td>-3 - 2</td></tr>
<tr><td>iter3</td><td>i =	-1	sum =	-5</td><td>-5 - 1</td></tr>
<tr><td>iter4</td><td>i =	0	sum =	-6</td><td>-6 + 0</td></tr>
<tr><td>iter5</td><td>i =	1	sum =	-6</td><td>-6 + 1</td></tr>
<tr><td>iter6</td><td>i =	2	sum =	-5</td><td>break;</td></tr>
</tbody></table>
<ol start="10">
<li>🌟🌟 </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Fill the blanks
use std::ops::{Range, RangeInclusive};
fn main() {
    assert_eq!((1..5), Range{ start: 1, end: 5 }); // Im going to be honest. I did not know about the Range type at all.
    assert_eq!((1..=5), RangeInclusive::new(1, 5)); // Just did basic troubleshooting with rust compiler to find the answers.

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="computations"><a class="header" href="#computations">Computations</a></h3>
<ol start="11">
<li>🌟 </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Fill the blanks and fix the errors
fn main() {
    // Integer addition
    assert!(1u32 + 2 == 3);

    // Integer subtraction
    assert!(1i32 - 2 == -1);
    assert!(1i8 - 2 == -1); // change to i8 as negative values are out of range 
    
    assert!(3 * 50 == 150);

    assert!(9.6_f32.abs() / 3.2_f32.abs() == 3.0); // Use absolute values

    assert!(24 % 5 == 4);
    // Short-circuiting boolean logic
    assert!(true &amp;&amp; false == false);
    assert!(true || false == true);
    assert!(!true == false);

    // Bitwise operations
    println!(&quot;0011 AND 0101 is {:04b}&quot;, 0b0011u32 &amp; 0b0101);
    println!(&quot;0011 OR 0101 is {:04b}&quot;, 0b0011u32 | 0b0101);
    println!(&quot;0011 XOR 0101 is {:04b}&quot;, 0b0011u32 ^ 0b0101);
    println!(&quot;1 &lt;&lt; 5 is {}&quot;, 1u32 &lt;&lt; 5);
    println!(&quot;0x80 &gt;&gt; 2 is 0x{:x}&quot;, 0x80u32 &gt;&gt; 2);
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="char-bool-and-unit"><a class="header" href="#char-bool-and-unit">Char, Bool and Unit</a></h1>
<h3 id="char"><a class="header" href="#char">Char</a></h3>
<ol>
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">// Make it work
use std::mem::size_of_val;
fn main() {
    let c1 = 'a';
    assert_eq!(size_of_val(&amp;c1),4); // char is 4 bytes 

    let c2 = '中';
    assert_eq!(size_of_val(&amp;c2),4); // similarly this is also 4 bytes.

    println!(&quot;Success!&quot;);
} 
</code></pre></pre>
<ol start="2">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">// Make it work
fn main() {
    let c1 = '中';

// Single quotes is for character and double quotes is for strings.
// This ain't Python. We have proper standards and conventions.

    print_char(c1);
} 

fn print_char(c : char) {
    println!(&quot;{}&quot;, c);
}
</code></pre></pre>
<h3 id="bool"><a class="header" href="#bool">Bool</a></h3>
<ol start="3">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">// Make println! work
fn main() {
    let f: bool = false;

    let t = f;

// Could've just removed the bang but, I guessed we had to use the unused variable.

    if !t {
        println!(&quot;Success!&quot;);
    }
} 
</code></pre></pre>
<ol start="4">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">// Make it work
fn main() {
    let f = true;
    let t = true || false;
    assert_eq!(t, f);

    println!(&quot;Success!&quot;);
}

</code></pre></pre>
<p>AND truth table:</p>
<table><thead><tr><th>X</th><th>Y</th><th>X&amp;Y</th></tr></thead><tbody>
<tr><td>true</td><td>false</td><td>false</td></tr>
<tr><td>false</td><td>true</td><td>false</td></tr>
<tr><td>false</td><td>false</td><td>false</td></tr>
<tr><td>true</td><td>true</td><td>true</td></tr>
</tbody></table>
<h3 id="unit-type"><a class="header" href="#unit-type">Unit type</a></h3>
<ol start="5">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Make it work, don't modify `implicitly_ret_unit` !
fn main() {
    let w: () = ();

    let v = (2, 3);
    assert_eq!(w, implicitly_ret_unit()); // I can't think of anything but changing the variable name

    println!(&quot;Success!&quot;);
}

fn implicitly_ret_unit() {
    println!(&quot;I will return a ()&quot;);
}

// Don't use this one
fn explicitly_ret_unit() -&gt; () {
    println!(&quot;I will return a ()&quot;);
}
</code></pre></pre>
<ol start="6">
<li>🌟🌟 What's the size of the unit type?</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Modify `4` in assert to make it work
use std::mem::size_of_val;
fn main() {
    let unit: () = ();
    assert!(size_of_val(&amp;unit) == 0); // size of unit type is zero

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="statements-and-expressions"><a class="header" href="#statements-and-expressions">Statements and Expressions</a></h1>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = 5u32;

    let y = {
        let x_squared = x * x;
        let x_cube = x_squared * x;

        // This expression will be assigned to `y`
        x_cube + x_squared + x
    };

    let z = {
        // The semicolon suppresses this expression and `()` is assigned to `z`
        2 * x
    };

    println!(&quot;x is {:?}&quot;, x);
    println!(&quot;y is {:?}&quot;, y);
    println!(&quot;z is {:?}&quot;, z);
}
</code></pre></pre>
<h3 id="exercises"><a class="header" href="#exercises">Exercises</a></h3>
<ol>
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 1) 
fn main() {
   let v = {
       let mut x = 1;
       x += 2;
       x
   };

   assert_eq!(v, 3);

   println!(&quot;Success!&quot;);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 2)
fn main() {
   let v = {
       let mut x = 1;
       x + 2
   };

   assert_eq!(v, 3);

   println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="2">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   let v = {let x = 3; x}; // Paranthesis can only be used for tuples.
// There should also be a return statement otherwise the expression will return ()
   assert!(v == 3);

   println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="3">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s = sum(1 , 2);
    assert_eq!(s, 3);

    println!(&quot;Success!&quot;);
}

// semicolon means the statement is not returning instead () is returned
fn sum(x: i32, y: i32) -&gt; i32 {
    x + y
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<ol>
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // Don't modify the following two lines!
    let (x, y) = (1, 2);
    let s = sum(x, y);

    assert_eq!(s, 3);

    println!(&quot;Success!&quot;);
}

// Each argument type must be declared because, rust hates ambiguity at run time.
fn sum(x: i32, y: i32) -&gt; i32 { // add a return type and remove semicolons to return expression
    x + y
}
</code></pre></pre>
<ol start="2">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
   print();
}

// Replace i32 with another type
fn print() -&gt; () { // No need to specify () just keeping it blank will suffice
   println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="3">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 1) Using panic to stop a program abruptly
#[allow(unreachable_code)]
fn main() {
    never_return();

    println!(&quot;Failed!&quot;);
}

fn never_return() -&gt; ! {
    // Implement this function, don't modify the fn signatures
   panic!(); 
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 2) Using never ending loop.
// This should never be used in real code.
#[allow(unreachable_code)]
fn main() {
    never_return();

    println!(&quot;Failed!&quot;);
}

fn never_return() -&gt; ! {
    // Implement this function, don't modify the fn signatures
   loop{}
}
</code></pre></pre>
<h3 id="diverging-functions"><a class="header" href="#diverging-functions">Diverging functions</a></h3>
<p>Diverging functions never return to the caller, so they may be used in places where a value of any type is expected.</p>
<ol start="4">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!(&quot;Success!&quot;);
}

fn get_option(tp: u8) -&gt; Option&lt;i32&gt; {
    match tp {
        1 =&gt; {
            // TODO
        }
        _ =&gt; {
            // TODO
        }
    };
    
    // Rather than returning a None, we use a diverging function instead
    never_return_fn()
}

// IMPLEMENT this function in THREE ways
// 1)
fn never_return_fn() -&gt; ! {
    panic!();
}

// 2)

// fn never_return_fn() -&gt; ! {
//     loop{}
// }

// 3)

// fn never_return_fn() -&gt; ! {
//     std::process::exit(1);
// }
</code></pre></pre>
<ol start="5">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // FILL in the blank
    let b = false;

    let v = match b {
        true =&gt; 1,
        // Diverging functions can also be used in match expression to replace a value of any value
        false =&gt; {
            println!(&quot;Success!&quot;);
            panic!(&quot;we have no value for `false`, but we can panic&quot;);
        }
    };

    println!(&quot;Exercise Failed if printing out this line!&quot;);
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-and-borrowing"><a class="header" href="#ownership-and-borrowing">Ownership and Borrowing</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">Rust Book 4.1-4.4</a></li>
<li>简体中文: <a href="https://course.rs/basic/ownership/index.html">Rust语言圣经 - 所有权与借用</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<ol>
<li>🌟🌟 </li>
</ol>
<ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // Use as many approaches as you can to make it work
    let x = String::from(&quot;hello, world&quot;);
    let y = x.clone();
    println!(&quot;{},{}&quot;,x,y);
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // using string slices.
    let x = String::from(&quot;hello, world&quot;);
    let y = &amp;x[..];
    println!(&quot;{},{}&quot;,x,y);
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // using &amp;String
    let x = &amp;String::from(&quot;hello, world&quot;);
    let y = x;
    println!(&quot;{},{}&quot;,x,y);
}
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // Storing &amp;str and copying that
    let x = &quot;hello, world&quot;;
    let y = x;
    println!(&quot;{},{}&quot;,x,y);
}
</code></pre></pre>
<ol start="2">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Don't modify code in main!
fn main() {
    let s1 = String::from(&quot;hello, world&quot;);
    let s2 = take_ownership(s1);

    println!(&quot;{}&quot;, s2);
}

// Only modify the code below!
fn take_ownership(s: String) -&gt; String {
    println!(&quot;{}&quot;, s);
    s // Temporarily s owns it but the owership is returned to s2
}
</code></pre></pre>
<ol start="3">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = give_ownership();
    println!(&quot;{}&quot;, s);
}

// Only modify the code below!
fn give_ownership() -&gt; String {
    let s = String::from(&quot;hello, world&quot;);
    // Convert String to Vec
    let _s = s.into_bytes(); // _s owns the string now
    String::from_utf8_lossy(&amp;_s).to_string() // Converting bytes to String

// Here to_string() is required as the type is actually a Cow
// Which basically is a type that holds a smart pointer that provides cloning when borrowed.
}
</code></pre></pre>
<ol start="4">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Fix the error without removing code line
fn main() {
    let s = String::from(&quot;hello, world&quot;);

    print_str(&amp;s[..]);

    println!(&quot;{}&quot;, s);
}

fn print_str(s: &amp;str)  {
    println!(&quot;{}&quot;,s)
}

// You can also do this: 
// fn main() {
//     let mut s = String::from(&quot;hello, world&quot;);
// 
//     s = print_str(s);
// 
//     println!(&quot;{}&quot;, s);
// }
// 
// fn print_str(s: String) -&gt; String {
//     println!(&quot;{}&quot;,s);
//     s
// }
</code></pre></pre>
<ol start="5">
<li>🌟🌟 </li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">// Don't use clone ,use copy instead
fn main() {
// Changing String to &amp;str works as &amp;str implements copy. 
    let x = (1, 2, (), &quot;hello&quot;);
    let y = x;
    println!(&quot;{:?}, {:?}&quot;, x, y);
}
</code></pre></pre>
<pre><code class="language-ignore">Why ownership in rust is an important concept:

* Rust doesn't have a garbage collector.
* Instead all the variables are dropped when they leave the scope much like c.
* This then poses a problem with pointers. First we have to understand how strings work.

What is a string?
=================

A string is a series of char with a pointer to the first char
stored in variable and a '\0' delimiter to denote end of the string.

example in c:
       ----                 -----
      |  &amp; |               |     |
      |    v               |     v
char* s = &quot;Rust is awesome!&quot;;   '\0' is appended

s holds the address of the char 'R'. Hence, s++ would be 'u'.

So when you something like

char* s1 = s; Here s1 is also a pointer that holds the address of 'R'.

In rust, because of the drop trait that is applied to the variables, at the end of the variable scope,

Now you have 2 pointers pointing to the same data.
If the rust compiler follows through and deletes the pointer and frees the memory it was pointing to,
Then the compiler will delete whatever else memory that the dangling pointer is pointing to.

This all can be solved by using ownership which basically just allows one pointer at a time to memory. Rust borrow-checker will
check the code and keep track of who the owner is at a given point in the code.
</code></pre>
<h4 id="you-guys-shouldve-been-a-little-considerate-of-people-with-jobs-before-giving-the-assignment-i-havent-slept-since-2-days-"><a class="header" href="#you-guys-shouldve-been-a-little-considerate-of-people-with-jobs-before-giving-the-assignment-i-havent-slept-since-2-days-">You guys should've been a little considerate of people with jobs before giving the assignment. I haven't slept since 2 days ...</a></h4>
<iframe src="https://giphy.com/embed/D12CsrRNv7gL6" width="480" height="360" frameBorder="0" class="giphy-embed"></iframe><p><a href="https://giphy.com/gifs/crazy-family-guy-lol-D12CsrRNv7gL6"></a></p>
<h4 id="mutability"><a class="header" href="#mutability">Mutability</a></h4>
<p>Mutability can be changed when ownership is transferred.</p>
<ol start="6">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = String::from(&quot;hello, &quot;);
    
    // Modify this line only !
    let mut s1 = s;

    s1.push_str(&quot;world&quot;);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="7">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = Box::new(5);
    
    let mut y = Box::new(420);      // Implement this line, dont change other lines!
    
    *y = 4;
    
    assert_eq!(*x, 5);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="partial-move"><a class="header" href="#partial-move">Partial move</a></h3>
<p>Within the destructuring of a single variable, both by-move and by-reference pattern bindings can be used at the same time. Doing this will result in a partial move of the variable, which means that parts of the variable will be moved while other parts stay. In such a case, the parent variable cannot be used afterwards as a whole, however the parts that are only referenced (and not moved) can still be used.</p>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    #[derive(Debug)]
    struct Person {
        name: String,
        age: Box&lt;u8&gt;,
    }

    let person = Person {
        name: String::from(&quot;Alice&quot;),
        age: Box::new(20),
    };

    // `name` is moved out of person, but `age` is referenced
    let Person { name, ref age } = person;

    println!(&quot;The person's age is {}&quot;, age);

    println!(&quot;The person's name is {}&quot;, name);

    // Error! borrow of partially moved value: `person` partial move occurs
    //println!(&quot;The person struct is {:?}&quot;, person);

    // `person` cannot be used but `person.age` can be used as it is not moved
    println!(&quot;The person's age from person struct is {}&quot;, person.age);
}
</code></pre></pre>
<h4 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h4>
<ol start="8">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;));

   let _s = t.0;

   // Modify this line only, don't use `_s`
   println!(&quot;{:?}&quot;, t.1); // since t.0 is borrowed we can only use t.1
}
</code></pre></pre>
<ol start="9">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
   let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;));

    // Fill the blanks
    let (s1, s2) = t.clone();

    println!(&quot;{:?}, {:?}, {:?}&quot;, s1, s2, t); // -&gt; &quot;hello&quot;, &quot;world&quot;, (&quot;hello&quot;, &quot;world&quot;)
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-and-borrowing"><a class="header" href="#reference-and-borrowing">Reference and Borrowing</a></h1>
<h3 id="reference"><a class="header" href="#reference">Reference</a></h3>
<ol>
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
   let x = 5;
   // Fill the blank
   let p = &amp;x;

   println!(&quot;the memory address of x is {:p}&quot;, p); // One possible output: 0x16fa3ac84
}
</code></pre></pre>
<ol start="2">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = 5;
    let y = &amp;x;

    // Modify this line only
    assert_eq!(5, *y);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="3">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Fix error
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    borrow_object(&amp;s); // argument expects &amp;string

    println!(&quot;Success!&quot;);
}

fn borrow_object(s: &amp;String) {}
</code></pre></pre>
<ol start="4">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Fix error
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    push_str(&amp;mut s); // Sending mutable reference

    println!(&quot;Success!&quot;);
}

fn push_str(s: &amp;mut String) {
    s.push_str(&quot;world&quot;)
}
</code></pre></pre>
<ol start="5">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    // Fill the blank to make it work
    let p = &amp;mut s;
    
    p.push_str(&quot;world&quot;);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h4 id="ref"><a class="header" href="#ref">Ref</a></h4>
<p><code>ref</code> can be used to take references to a value, similar to <code>&amp;</code>.</p>
<ol start="6">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let c = '中';

    let r1 = &amp;c;
    // Fill the blank，dont change other code
    let ref r2 = c; // ref type makes working with addresses and pointers a little safer.

    assert_eq!(*r1, *r2);
    
    // Check the equality of the two address strings
    assert_eq!(get_addr(r1),get_addr(r2));

    println!(&quot;Success!&quot;);
}

// Get memory address string
fn get_addr(r: &amp;char) -&gt; String {
    format!(&quot;{:p}&quot;, r)
}
</code></pre></pre>
<h3 id="borrowing-rules"><a class="header" href="#borrowing-rules">Borrowing rules</a></h3>
<ol start="7">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Remove something to make it work
// Don't remove a whole line !
fn main() {
    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s;
    let r2 = &amp;s; // no need to mutate

    println!(&quot;{}, {}&quot;, r1, r2);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h4 id="mutability-1"><a class="header" href="#mutability-1">Mutability</a></h4>
<ol start="8">
<li>🌟 Error: Borrow an immutable object as mutable</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // Fix error by modifying this line
    let mut s = String::from(&quot;hello, &quot;); //  cannot be mutated if the original variable ain't mutable.

    borrow_object(&amp;mut s);

    println!(&quot;Success!&quot;);
}

fn borrow_object(s: &amp;mut String) {}
</code></pre></pre>
<ol start="9">
<li>🌟🌟 Ok: Borrow a mutable object as immutable</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// This code has no errors!
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    borrow_object(&amp;s);
    
    s.push_str(&quot;world&quot;);

    println!(&quot;Success!&quot;);
}

fn borrow_object(s: &amp;String) {}
</code></pre></pre>
<h3 id="nll"><a class="header" href="#nll">NLL</a></h3>
<ol start="10">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Comment one line to make it work
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    let r1 = &amp;mut s;
    r1.push_str(&quot;world&quot;);
    let r2 = &amp;mut s;
    r2.push_str(&quot;!&quot;);
    
    // println!(&quot;{}&quot;,r1); cause s is borrowed to r2 now
}
</code></pre></pre>
<ol start="11">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    // Add one line below to make a compiler error: cannot borrow `s` as mutable more than once at a time
    // You can't use r1 and r2 at the same time
	
    r1.push_str(r2);
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch04-03-slices.html">Rust Book 4.3, 5.1, 6.1, 8.2</a></li>
<li>简体中文: <a href="https://course.rs/basic/compound-type/intro.html">Rust语言圣经 - 复合类型</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">String</a></h1>
<p>The type of string literal <code>&quot;hello, world&quot;</code> is <code>&amp;str</code>, e.g <code>let s: &amp;str = &quot;hello, world&quot;</code>.</p>
<h3 id="str-and-str"><a class="header" href="#str-and-str">Str and &amp;str</a></h3>
<ol>
<li>🌟 We can't use <code>str</code> type in normal ways, but we can use <code>&amp;str</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Fix error without adding new line
fn main() {
    let s: &amp;str = &quot;hello, world&quot;; // it is &amp;str not str

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="2">
<li>🌟🌟 We can only use <code>str</code> by boxed it, <code>&amp;</code> can be used to convert <code>Box&lt;str&gt;</code> to <code>&amp;str</code> </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Fix the error with at least two solutions
fn main() {
    let s: Box&lt;str&gt; = &quot;hello, world&quot;.into();
    greetings(&amp;s);
}

fn greetings(s: &amp;str) {
    println!(&quot;{}&quot;,s)
}
</code></pre></pre>
<h3 id="string-1"><a class="header" href="#string-1">String</a></h3>
<p><code>String</code> type is defined in std and stored as a vector of bytes (Vec<u8>), but guaranteed to always be a valid UTF-8 sequence. String is heap allocated, growable and not null terminated.</p>
<ol start="3">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// Fill the blank
fn main() {
    let mut s = String::new();
    s.push_str(&quot;hello, world&quot;);
    s.push('!');

    assert_eq!(s, &quot;hello, world!&quot;);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="4">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// Fix all errors without adding newline
fn main() {
    let mut s = String::from(&quot;hello&quot;);
    s.push(',');
    s.push_str(&quot; world&quot;);
    s += &quot;!&quot;;

    println!(&quot;{}&quot;, s);
}
</code></pre></pre>
<ol start="5">
<li>🌟🌟 <code>replace</code> can be used to replace substring</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// Fill the blank
fn main() {
    let s = String::from(&quot;I like dogs&quot;);
    // Allocate new memory and store the modified string there
    let s1 = s.replace(&quot;dogs&quot;, &quot;cats&quot;);

    assert_eq!(s1, &quot;I like cats&quot;);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<p>More <code>String</code> methods can be found under <a href="https://doc.rust-lang.org/std/string/struct.String.html">String</a> module.</p>
<ol start="6">
<li>🌟🌟 You can only concat a <code>String</code> with <code>&amp;str</code>, and <code>String</code>'s ownership can be moved to another variable.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// Fix errors without removing any line
fn main() {
    let s1 = String::from(&quot;hello,&quot;);
    let s2 = String::from(&quot;world!&quot;);
    let s3 = s1.clone() + &amp;s2; 
    assert_eq!(s3,&quot;hello,world!&quot;);
    println!(&quot;{}&quot;,s1);
}
</code></pre></pre>
<h3 id="str-and-string"><a class="header" href="#str-and-string">&amp;str and String</a></h3>
<p>Opsite to the seldom using of <code>str</code>, <code>&amp;str</code> and <code>String</code> are used everywhere!</p>
<ol start="7">
<li>🌟🌟 <code>&amp;str</code> can be converted to <code>String</code> in two ways</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 1)
fn main() {
    let s = String::from(&quot;hello, world&quot;);
    greetings(s);
}

fn greetings(s: String) {
    println!(&quot;{}&quot;,s)
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 2)
fn main() {
    let s = &quot;hello, world&quot;.to_string();
    greetings(s);
}

fn greetings(s: String) {
    println!(&quot;{}&quot;,s)
}
</code></pre></pre>
<ol start="8">
<li>🌟🌟 We can use <code>String::from</code> or <code>to_string</code> to convert a <code>&amp;str</code> to <code>String</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = &quot;hello, world&quot;.to_string();
    let s1: &amp;str = &amp;s[..];

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="string-escapes"><a class="header" href="#string-escapes">String escapes</a></h3>
<ol start="9">
<li>🌟 </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // You can use escapes to write bytes by their hexadecimal values
    // Fill the blank below to show &quot;I'm writing Rust&quot;
    let byte_escape = &quot;I'm writing Ru\x73__!&quot;;
    println!(&quot;What are you doing\x3F (\\x3F means ?) {}&quot;, byte_escape);

    // ...Or Unicode code points.
    let unicode_codepoint = &quot;\u{211D}&quot;;
    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;

    println!(&quot;Unicode character {} (U+211D) is called {}&quot;,
                unicode_codepoint, character_name );

   let long_string = &quot;String literals
                        can span multiple lines.
                        The linebreak and indentation here \
                         can be escaped too!&quot;;
    println!(&quot;{}&quot;, long_string);
}
</code></pre></pre>
<ol start="10">
<li>🌟🌟🌟 Sometimes there are just too many characters that need to be escaped or it's just much more convenient to write a string out as-is. This is where raw string literals come into play.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* Fill in the blank and fix the errors */
fn main() {
    let raw_str = &quot;Escapes don't work here: \x3F \u{211D}&quot;;
    assert_eq!(raw_str, &quot;Escapes don't work here: ? ℝ&quot;);

    // If you need quotes in a raw string, add a pair of #s
    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;
    println!(&quot;{}&quot;, quotes);

    // If you need &quot;# in your string, just use more #s in the delimiter.
    // You can use up to 65535 #s.
    let  delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;
    println!(&quot;{}&quot;, delimiter);

    let long_delimiter = r###&quot;Hello, &quot;##&quot;&quot;###;
    assert_eq!(long_delimiter, &quot;Hello, \&quot;##\&quot;&quot;);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="byte-string"><a class="header" href="#byte-string">Byte string</a></h3>
<p>Want a string that's not UTF-8? (Remember, str and String must be valid UTF-8). Or maybe you want an array of bytes that's mostly text? Byte strings to the rescue!</p>
<p><strong>Example</strong>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::str;

fn main() {
    // Note that this is not actually a `&amp;str`
    let bytestring: &amp;[u8; 21] = b&quot;this is a byte string&quot;;

    // Byte arrays don't have the `Display` trait, so printing them is a bit limited
    println!(&quot;A byte string: {:?}&quot;, bytestring);

    // Byte strings can have byte escapes...
    let escaped = b&quot;\x52\x75\x73\x74 as bytes&quot;;
    // ...But no unicode escapes
    // let escaped = b&quot;\u{211D} Is not allowed&quot;;
    println!(&quot;Some escaped bytes: {:?}&quot;, escaped);


    // Raw byte strings work just like raw strings
    let raw_bytestring = br&quot;\u{211D} is not escaped here&quot;;
    println!(&quot;{:?}&quot;, raw_bytestring);

    // Converting a byte array to `str` can fail
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!(&quot;And the same as text: '{}'&quot;, my_str);
    }

    let _quotes = br#&quot;You can also use &quot;fancier&quot; formatting, \
                    like with normal raw strings&quot;#;

    // Byte strings don't have to be UTF-8
    let shift_jis = b&quot;\x82\xe6\x82\xa8\x82\xb1\x82\xbb&quot;; // &quot;ようこそ&quot; In SHIFT-JIS

    // But then they can't always be converted to `str`
    match str::from_utf8(shift_jis) {
        Ok(my_str) =&gt; println!(&quot;Conversion successful: '{}'&quot;, my_str),
        Err(e) =&gt; println!(&quot;Conversion failed: {:?}&quot;, e),
    };
}
</code></pre></pre>
<p>A more detailed listing of the ways to write string literals and escape characters is given in the <a href="https://doc.rust-lang.org/reference/tokens.html">'Tokens' chapter</a> of the Rust Reference.</p>
<h3 id="string-index"><a class="header" href="#string-index">String index</a></h3>
<ol start="11">
<li>🌟🌟🌟 You can't use index to access a char in a string, but you can use slice <code>&amp;s1[start..end]</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s1 = String::from(&quot;hi,中国&quot;);
    let h = s1[0..1]; // h is only one byte 
    assert_eq!(h, &quot;h&quot;);

    let h1 = &amp;s1[3..6]; // the symbol '中' is 2 bytes long
    assert_eq!(h1, &quot;中&quot;);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="operate-on-utf8-string"><a class="header" href="#operate-on-utf8-string">Operate on UTF8 string</a></h3>
<ol start="12">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // Fill the blank to print each char in &quot;你好，世界&quot;
    for c in &quot;你好，世界&quot;.chars() {
// chars() creates iterator of chars
        println!(&quot;{}&quot;, c)
    }
}
</code></pre></pre>
<h4 id="utf8_slice"><a class="header" href="#utf8_slice">utf8_slice</a></h4>
<p>You can use <a href="https://docs.rs/utf8_slice/1.0.0/utf8_slice/fn.slice.html">utf8_slice</a> to slice UTF8 string, it can index chars instead of bytes.</p>
<p><strong>Example</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">use utf8_slice;
fn main() {
    let s = &quot;The 🚀 goes to the 🌑!&quot;;

    let rocket = utf8_slice::slice(s, 4, 5);
    // Will equal &quot;🚀&quot;
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array"><a class="header" href="#array">Array</a></h1>
<p>The type of array is <code>[T; Length]</code>, as you can see, array's length is part of their type signature. So their length must be known at compile time.</p>
<p>For example, you cant initialize an array like below:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init_arr(n: i32) {
    let arr = [1; n];
}
<span class="boring">}
</span></code></pre></pre>
<p>This will cause an error, because the compiler has no idea of the exact size of the array at compile time.</p>
<ol>
<li>🌟 </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // Fill the blank with proper array type
    let arr: [u8; 5] = [1, 2, 3, 4, 5];

    // Modify the code below to make it work
    assert!(arr.len() == 5);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="2">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // We can ignore parts of the array type or even the whole type, let the compiler infer it for us
    let arr0 = [1, 2, 3];
    let arr: [char; 3] = ['a', 'b', 'c'];
    
    // Fill the blank
    // Arrays are stack allocated, `std::mem::size_of_val` returns the bytes which an array occupies
    // A char takes 4 bytes in Rust: Unicode char
    assert!(std::mem::size_of_val(&amp;arr) == 12); // cause 4 x 3 = 12 quik mafs

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="3">
<li>🌟 All elements in an array can be initialized to the same value at once.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let list: [i32; 100] = [1; 100];

    assert!(list[0] == 1);
    assert!(list.len() == 100);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="4">
<li>🌟 All elements in an array must be of the same type</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let _arr = [1, 2, 3];// array are homogenous unlike tuples

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="5">
<li>🌟 Indexing starts at 0.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let arr = ['a', 'b', 'c'];
    
    let ele = arr[0]; // Only modify this line to make the code work!

    assert!(ele == 'a');

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="6">
<li>🌟 Out of bounds indexing causes <code>panic</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let names = [String::from(&quot;Sunfei&quot;), &quot;Sunface&quot;.to_string()];
    
    // `Get` returns an Option&lt;T&gt;, it's safe to use
    let name0 = names.get(0).unwrap();

    // But indexing is not safe
    let _name1 = &amp;names[1];

    println!(&quot;Success!&quot;);
}

</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slice"><a class="header" href="#slice">Slice</a></h1>
<p>Slices are similar to arrays, but their length is not known at compile time, so you can't use slice directly.</p>
<ol>
<li>🌟🌟 Here, both <code>[i32]</code> and <code>str</code> are slice types, but directly using it will cause errors. You have to use the reference of the slice instead: <code>&amp;[i32]</code>, <code>&amp;str</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Fix the errors, DON'T add new lines!
fn main() {
    let arr = [1, 2, 3];
    let s1: &amp;[i32] = &amp;arr[0..2];

    let s2: &amp;str = &quot;hello, world&quot;;

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<p>A slice reference is a two-word object, for simplicity reasons, from now on we will use slice instead of <code>slice reference</code>.  The first word is a pointer to the data, and the second word is the length of the slice. The word size is the same as usize, determined by the processor architecture, eg 64 bits on an x86-64. Slices can be used to borrow a section of an array, and have the type signature <code>&amp;[T]</code>.</p>
<ol start="2">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let arr: [char; 3] = ['中', '国', '人'];

    let slice = &amp;arr[..2];
    
    // Modify '6' to make it work
    // TIPS: slice( reference ) IS NOT an array, if it is an array, then `assert!` will passed: Each of the two UTF-8 chars '中' and '国'  occupies 3 bytes, 2 * 3 = 6
    assert!(std::mem::size_of_val(&amp;slice) == 16);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="3">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let arr: [i32; 5] = [1, 2, 3, 4, 5];
    // Fill the blanks to make the code work
    let slice: &amp;[i32] = &amp;arr[1..4];
    assert_eq!(slice, &amp;[2, 3, 4]);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="string-slices"><a class="header" href="#string-slices">String slices</a></h3>
<ol start="4">
<li>🌟 </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = String::from(&quot;hello&quot;);

    let slice1 = &amp;s[0..2];
    // Fill the blank to make the code work, DON'T USE 0..2 again
    let slice2 = &amp;s[..2];

    assert_eq!(slice1, slice2);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="5">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = &quot;你好，世界&quot;;
    // Modify this line to make the code work
    let slice = &amp;s[0..3];

    assert!(slice == &quot;你&quot;);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="6">
<li>🌟🌟 <code>&amp;String</code> can be implicitly converted into <code>&amp;str</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    println!(&quot;the first word is: {}&quot;, word);
    
    s.clear();

}
fn first_word(s: &amp;str) -&gt; &amp;str {
    &amp;s[..1]
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuple"><a class="header" href="#tuple">Tuple</a></h1>
<ol>
<li>🌟 Elements in a tuple can have different types. Tuple's type signature is <code>(T1, T2, ...)</code>, where <code>T1</code>, <code>T2</code> are the types of tuple's members.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let _t0: (u8,i16) = (0, -1);
    let _t1: (u8, (i16, u32)) = (0, (-1, 1));
    let t: (u8, u16, i64, &amp;str, String) = (1u8, 2u16, 3i64, &quot;hello&quot;, String::from(&quot;, world&quot;));

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="2">
<li>🌟 Members can be extracted from the tuple using indexing.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let t = (&quot;i&quot;, &quot;am&quot;, &quot;sunface&quot;);
    assert_eq!(t.2, &quot;sunface&quot;);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="3">
<li>🌟 Long tuples  cannot be printed</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Fix the error
fn main() {
    let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);
    println!(&quot;too long tuple: {:?}&quot;, too_long_tuple);
}
</code></pre></pre>
<ol start="4">
<li>🌟 Destructuring tuple with pattern.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let tup = (1, 6.4, &quot;hello&quot;);

    let (x, z, y) = tup;

    assert_eq!(x, 1);
    assert_eq!(y, &quot;hello&quot;);
    assert_eq!(z, 6.4);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="5">
<li>🌟🌟 Destructure assignments.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let (x, y, z);

    // Fill the blank
    (y, z, x) = (1, 2, 3);
    
    assert_eq!(x, 3);
    assert_eq!(y, 1);
    assert_eq!(z, 2);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="6">
<li>🌟🌟 Tuples can be used as function arguments and return values</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // Fill the blank, need a few computations here.
    let (x, y) = sum_multiply((2, 3));

    assert_eq!(x, 5);
    assert_eq!(y, 6);

    println!(&quot;Success!&quot;);
}

fn sum_multiply(nums: (i32, i32)) -&gt; (i32, i32) {
    (nums.0 + nums.1, nums.0 * nums.1)
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct"><a class="header" href="#struct">Struct</a></h1>
<h3 id="the-types-of-structs"><a class="header" href="#the-types-of-structs">The types of structs</a></h3>
<ol>
<li>🌟 We must specify concrete values for each of the fields in struct.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// Fix the error
struct Person {
    name: String,
    age: u8,
    hobby: String
}
fn main() {
    let age = 23;
    let p = Person {
        name: String::from(&quot;Rehaan&quot;),
        age: age,
        hobby: String::from(&quot;sketching&quot;),
    };

    println!(&quot;Success!&quot;);
} 
</code></pre></pre>
<ol start="2">
<li>🌟 Unit struct don't have any fields. It can be useful when you need to implement a trait on some type but don’t have any data that you want to store in the type itself. </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Unit;
trait SomeTrait {
    // ...Some behaviors defined here.
}

// We don't care about what fields  are  in the Unit, but we care about its behaviors.
// So we use a struct with no fields and implement some behaviors for it
impl SomeTrait for Unit {  }
fn main() {
    let u = Unit;
    do_something_with_unit(u);

    println!(&quot;Success!&quot;);
} 

// Fill the blank to make the code work
fn do_something_with_unit(u: Unit){ }  
// One could also use this 
// fn do_something_with_unit&lt;T&gt;(u: T) where T: SomeTrait{ }
</code></pre></pre>
<ol start="3">
<li>🌟🌟🌟 Tuple struct looks similar to tuples, it has added meaning the struct name provides but has no named fields. It's useful when you want to give the whole tuple a name, but don't care about the fields's names.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// Fix the error and fill the blanks
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
fn main() {
    let v = Point(0, 127, 255);
    check_color(v);

    println!(&quot;Success!&quot;);
}   

fn check_color(p: Point) {
    let Point(x, _, _) = p;
    assert_eq!(x, 0);
    assert_eq!(p.1, 127);
    assert_eq!(p.2, 255);
 }
</code></pre></pre>
<h3 id="operating-on-structs"><a class="header" href="#operating-on-structs">Operating on structs</a></h3>
<ol start="4">
<li>🌟 You can make a whole struct mutable when instantiating it, but Rust doesn't allow us to mark only certain fields as mutable.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Person {
    name: String,
    age: u8,
}
fn main() {
    let age = 18;
    let mut p = Person {
        name: String::from(&quot;sunface&quot;),
        age,
    };
// Our lord sunface is definitely older than 18
    p.age = 30;

    p.name = String::from(&quot;sunfei&quot;);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="5">
<li>🌟 Using <em>field init shorthand syntax</em> to reduce repetitions.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Person {
    name: String,
    age: u8,
}
fn main() {
    println!(&quot;Success!&quot;);
} 

fn build_person(name: String, age: u8) -&gt; Person {
    Person {
        age,
        name 
    }
}
</code></pre></pre>
<ol start="6">
<li>🌟 You can create instance from other instance with <em>struct update syntax</em></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
fn main() {
    let u1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;sunface&quot;),
        active: true,
        sign_in_count: 1,
    };

    let u2 = set_email(u1);

    println!(&quot;Success!&quot;);
} 

fn set_email(u: User) -&gt; User {
    User {
        email: String::from(&quot;contact@im.dev&quot;),
        ..u
    }
}
</code></pre></pre>
<h3 id="print-the-structs"><a class="header" href="#print-the-structs">Print the structs</a></h3>
<ol start="7">
<li>🌟🌟 We can use <code>#[derive(Debug)]</code> to <a href="https://doc.rust-lang.org/book/ch05-02-example-structs.html?highlight=%23%5Bderive(Debug)%5D#adding-useful-functionality-with-derived-traits">make a struct printable</a>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale), // Print debug info to stderr and assign the value of  `30 * scale` to `width`
        height: 50,
    };

    dbg!(&amp;rect1); // Print debug info to stderr

    println!(&quot;{:#?}&quot;, rect1); // Print debug info to stdout
}
</code></pre></pre>
<h3 id="partial-move-1"><a class="header" href="#partial-move-1">Partial move</a></h3>
<p>Within the destructuring of a single variable, both by-move and by-reference pattern bindings can be used at the same time. Doing this will result in a partial move of the variable, which means that parts of the variable will be moved while other parts stay. In such a case, the parent variable cannot be used afterwards as a whole, however the parts that are only referenced (and not moved) can still be used.</p>
<h4 id="example-1"><a class="header" href="#example-1">Example</a></h4>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    #[derive(Debug)]
    struct Person {
        name: String,
        age: Box&lt;u8&gt;,
    }

    let person = Person {
        name: String::from(&quot;Alice&quot;),
        age: Box::new(20),
    };

    // `name` is moved out of person, but `age` is referenced
    let Person { name, ref age } = person;

    println!(&quot;The person's age is {}&quot;, age);

    println!(&quot;The person's name is {}&quot;, name);

    // Error! borrow of partially moved value: `person` partial move occurs
    //println!(&quot;The person struct is {:?}&quot;, person);

    // `person` cannot be used but `person.age` can be used as it is not moved
    println!(&quot;The person's age from person struct is {}&quot;, person.age);
}
</code></pre></pre>
<h4 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h4>
<ol start="8">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct File {
    name: String,
    data: String,
}
fn main() {
    let f = File {
        name: String::from(&quot;readme.md&quot;),
        data: &quot;Rust By Practice&quot;.to_string()
    };

    let _name = f.name;

    println!(&quot;{}, {}&quot;, _name, f.data);
} 
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum"><a class="header" href="#enum">Enum</a></h1>
<ol>
<li>🌟🌟 Enums can be created with explicit discriminator.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Number {
    Zero,
    One,
    Two,
}

enum Number1 {
    Zero = 0,
    One,
    Two,
}

// Enum cannot be floats. They can however hold float values.
enum Number2 {
    Zero = 0,
    One = 1,
    Two = 2,
}


fn main() {
    assert_eq!(Number::One as isize, Number1::One as isize);
    assert_eq!(Number1::One as isize, Number2::One as isize);

    println!(&quot;Success!&quot;);
} 
</code></pre></pre>
<ol start="2">
<li>🌟 Each enum variant can hold its own data.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg1 = Message::Move{x: 1, y: 2}; // Instantiating with x = 1, y = 2 
    let msg2 = Message::Write(String::from(&quot;hello, world!&quot;)); // Instantiating with &quot;hello, world!&quot;

    println!(&quot;Success!&quot;);
} 
</code></pre></pre>
<ol start="3">
<li>🌟🌟 We can get the data which an enum variant is holding by pattern match.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::Move{x: 1, y: 1};

    if let Message::Move{x: a, y: b} = msg {
        assert_eq!(a, b);
    } else {
        panic!(&quot;WHY ARE YOU RUNNING! &quot;);
    }

    println!(&quot;Success!&quot;);
} 
</code></pre></pre>
<ol start="4">
<li>🌟🌟 </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msgs: [Message; 3] = [
        Message::Quit,
        Message::Move{x:1, y:3},
        Message::ChangeColor(255,255,0)
    ];

    for msg in msgs {
        show_message(msg)
    }
} 

fn show_message(msg: Message) {
    println!(&quot;{:#?}&quot;, msg);
}
</code></pre></pre>
<ol start="5">
<li>🌟🌟 Since there is no <code>null</code> in Rust, we have to use enum  <code>Option&lt;T&gt;</code>  to deal with the cases when the value is absent.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let five = Some(5);
    let six = plus_one(five);
    let _none = plus_one(None);

    if let Some(n) = six {
        println!(&quot;{}&quot;, n);
        println!(&quot;Success!&quot;);
        return
    } 
        
    panic!(&quot;WHY ARE YOU RUNNING！&quot;);
} 

fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}
</code></pre></pre>
<ol start="6">
<li>🌟🌟🌟🌟 Implement a <code>linked-list</code> via enums.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use crate::List::*;

enum List {
    Cons(u32, Box&lt;List&gt;),
    Nil,
}

impl List {
    fn new() -&gt; List {
        List::Nil
    }

    // Consume a list, and return the same list with a new element at its front
    fn prepend(self, elem: u32) -&gt; Self {
        Cons(elem, Box::new(self))
    }

    // Return the length of the list
    fn len(&amp;self) -&gt; u32 {
        match *self {
            Cons(_, ref tail) =&gt; 1 + tail.len(), // recurssion
            Nil =&gt; 0
        }
    }

    fn stringify(&amp;self) -&gt; String {
        match *self {
            Cons(head, ref tail) =&gt; {
                format!(&quot;{}, {}&quot;, head, tail.len())
            },
            Nil =&gt; {
                format!(&quot;Nil&quot;)
            },
        }
    }
}

fn main() {
    let mut list = List::new();

    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    println!(&quot;linked list has length: {}&quot;, list.len());
    println!(&quot;{}&quot;, list.stringify());
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flow-control"><a class="header" href="#flow-control">Flow control</a></h1>
<h3 id="ifelse"><a class="header" href="#ifelse">If/else</a></h3>
<ol>
<li>🌟 </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let n = 5;

    if n &lt; 0 {
        println!(&quot;{} is negative&quot;, n);
    } else if n &gt; 0 {
        println!(&quot;{} is positive&quot;, n);
    } else {
        println!(&quot;{} is zero&quot;, n);
    }
} 
</code></pre></pre>
<ol start="2">
<li>🌟🌟 <code>If/else</code> expression can be used in assignments.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let n = 5;

    let big_n =
        if n &lt; 10 &amp;&amp; n &gt; -10 {
            println!(&quot;, and is a small number, increase ten-fold&quot;);
            10 * n
        } else {
            println!(&quot;, and is a big number, halve the number&quot;);
            n / 2
        };

    println!(&quot;{} -&gt; {}&quot;, n, big_n);
} 
</code></pre></pre>
<h3 id="for"><a class="header" href="#for">For</a></h3>
<ol start="3">
<li>🌟 The <code>for in</code> construct can be used to iterate through an Iterator, e.g a range <code>a..b</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    for n in 1..100 { // modify this line to make the code work
        if n == 100 {
            panic!(&quot;NEVER LET THIS RUN &quot;)
        }
    }

    println!(&quot;Success!&quot;);
} 
</code></pre></pre>
<ol start="4">
<li>🌟🌟 </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let names = [String::from(&quot;liming&quot;),String::from(&quot;hanmeimei&quot;)];
    for name in &amp;names {
        println!(&quot;{} is cool&quot;, name);
    }

    println!(&quot;{:?}&quot;, names);

    let numbers = [1, 2, 3];
    for n in numbers {
        println!(&quot;{}&quot;, n); 
    }
    
    println!(&quot;{:?}&quot;, numbers);
} 
</code></pre></pre>
<ol start="5">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let a = [4, 3, 2, 1];

    for (i,v) in a.iter().enumerate() {
        println!(&quot;The {}th element is {}&quot;,i+1,v);
    }
}
</code></pre></pre>
<h3 id="while"><a class="header" href="#while">While</a></h3>
<ol start="6">
<li>🌟🌟 The <code>while</code> keyword can be used to run a loop when a condition is true.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut n = 1;

    while n &lt;= 30 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }


        n += 1;
    }

    println!(&quot;n reached {}, so loop is over&quot;,n);
}
</code></pre></pre>
<h3 id="continue-and-break"><a class="header" href="#continue-and-break">Continue and break</a></h3>
<ol start="7">
<li>🌟 Use <code>break</code> to break the loop.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut n = 0;
    for i in 0..=100 {
       if n == 66 {
           break; 
       }
       n += 1;
    }

    assert_eq!(n, 66);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="8">
<li>🌟🌟 <code>continue</code> will skip over the remaining code in current iteration and go to the next iteration.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut n = 0;
    for i in 0..=100 {
       if n != 66 {
           n+=1;
           continue;
       }
       
       break;
    }

    assert_eq!(n, 66);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="loop"><a class="header" href="#loop">Loop</a></h3>
<ol start="9">
<li>🌟🌟 Loop is usually used together with <code>break</code> or <code>continue</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut count = 0u32;

    println!(&quot;Let's count until infinity!&quot;);

    loop {
        count += 1;

        if count == 3 {
            println!(&quot;three&quot;);
            continue;
        }

        println!(&quot;{}&quot;, count);

        if count == 5 {
            println!(&quot;OK, that's enough&quot;);

            break;
        }
    }

    assert_eq!(count, 5);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="10">
<li>🌟🌟 Loop is an expression, so we can use it with <code>break</code> to return a value</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    assert_eq!(result, 20);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="11">
<li>🌟🌟🌟 It's possible to break or continue outer loops when dealing with nested loops. In these cases, the loops must be annotated with some 'label, and the label must be passed to the break/continue statement.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut count = 0;
    'outer: loop {
        'inner1: loop {
            if count &gt;= 20 {
                // This would break only the inner1 loop
                break 'inner1; // `break` is also works.
            }
            count += 2;
        }

        count += 5;

        'inner2: loop {
            if count &gt;= 30 {
                break 'outer;
            }

            continue 'outer;
        }
    }

    assert!(count == 30);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-match"><a class="header" href="#pattern-match">Pattern Match</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch18-00-patterns.html">Rust Book 18</a></li>
<li>简体中文: <a href="https://course.rs/basic/match-pattern/intro.html">Rust语言圣经 - 模式匹配</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-if-let"><a class="header" href="#match-if-let">Match, if let</a></h1>
<h3 id="match"><a class="header" href="#match">Match</a></h3>
<ol>
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East =&gt; println!(&quot;East&quot;),
        Direction::South | Direction::North  =&gt; {
            println!(&quot;South or North&quot;);
        },
        _ =&gt; println!(&quot;YOU SHALL NOT BE HERE!&quot;),
    };
}
</code></pre></pre>
<ol start="2">
<li>🌟🌟 Match is an expression, so we can use it in assignments.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let boolean = true;

    let binary = match boolean {
        true =&gt; 1,
        false =&gt; 0,
    };

    assert_eq!(binary, 1);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="3">
<li>🌟🌟 Using match to get the data an enum variant holds.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msgs = [
        Message::Quit,
        Message::Move{x:1, y:3},
        Message::ChangeColor(255,255,0)
    ];

    for msg in msgs {
        show_message(msg)
    }

    println!(&quot;Success!&quot;);
} 

fn show_message(msg: Message) {
    match msg {
        Message::Move{x: a, y: b} =&gt; {
            assert_eq!(a, 1);
            assert_eq!(b, 3);
        },
        Message::ChangeColor(_, g, b) =&gt; {
            assert_eq!(g, 255);
            assert_eq!(b, 0);
        }
        _ =&gt; println!(&quot;no data in these variants&quot;)
    }
}
</code></pre></pre>
<h3 id="matches"><a class="header" href="#matches">matches!</a></h3>
<p><a href="https://doc.rust-lang.org/stable/core/macro.matches.html"><code>matches!</code></a> looks like <code>match</code>, but can do something different.</p>
<ol start="4">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let alphabets = ['a', 'E', 'Z', '0', 'x', '9' , 'Y'];

    for ab in alphabets {
        assert!(matches!(ab, 'a'..='z' | 'A'..='Z' | '0'..='9')); 
        // checking with regular expression?
        // &quot;matches&quot; macro is new to me. Very interesting though.
        // I can already imagine it being used for validating stuff.
    }

    println!(&quot;Success!&quot;);
} 
</code></pre></pre>
<ol start="5">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum MyEnum {
    Foo,
    Bar
}

fn main() {
    let mut count = 0;

    let v = vec![MyEnum::Foo,MyEnum::Bar,MyEnum::Foo];
    for e in v {
        if matches!(e, MyEnum::Foo) {
            // &quot;matches&quot; macro seems quite handy.
            // NOICE
            count += 1;
        }
    }

    assert_eq!(count, 2);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="if-let"><a class="header" href="#if-let">If let</a></h3>
<p>For some cases, when matching enums, <code>match</code> is too heavy. We can use <code>if let</code> instead.</p>
<ol start="6">
<li>🌟 </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let o = Some(7);

    if let Some(i) = o {
        println!(&quot;This is a really long string and `{:?}`&quot;, i);
        println!(&quot;Success!&quot;);
    };
}
</code></pre></pre>
<ol start="7">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Foo {
    Bar(u8)
}

fn main() {
    let a = Foo::Bar(1);

    if let Foo::Bar(i) = a {
        println!(&quot;foobar holds the value: {}&quot;, i);
        println!(&quot;Success!&quot;);
    }
}
</code></pre></pre>
<ol start="8">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Foo {
    Bar,
    Baz,
    Qux(u32)
}

fn main() {
    let a = Foo::Qux(10);

    match a {
       Foo::Bar =&gt;  println!(&quot;match foo::bar&quot;),
       Foo::Baz =&gt;  println!(&quot;match foo::baz&quot;),
       _ =&gt; println!(&quot;match others&quot;),
    }
}
</code></pre></pre>
<h3 id="shadowing-1"><a class="header" href="#shadowing-1">Shadowing</a></h3>
<ol start="9">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let age = Some(30);
    if let Some(age) = age {
       assert_eq!(age, 30);
    }
    
    match age {
        Some(age) =&gt;  println!(&quot;age is a new variable, it's value is {}&quot;,age),
        _ =&gt; ()
    }
 }
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patterns"><a class="header" href="#patterns">Patterns</a></h1>
<ol>
<li>🌟🌟 Use <code>|</code> to match several values, use <code>..=</code> to match an inclusive range.</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>fn match_number(n: i32) {
    match n {
	1 =&gt; println!(&quot;One!&quot;),
	
	2 | 3 | 4 | 5 =&gt; println!(&quot;match 2 -&gt; 5&quot;),
	
	6..=10 =&gt; println!(&quot;match 6 -&gt; 10&quot;),

	_ =&gt; println!(&quot;match 11 -&gt; +infinite&quot;)
    }
}
<span class="boring">match_number(4);
</span><span class="boring">} 
</span></code></pre></pre>
<ol start="2">
<li>🌟🌟🌟 The <code>@</code> operator lets us create a variable that holds a value, at the same time we are testing that value to see whether it matches a pattern.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 5, y: 10 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        Point { x: 0..=5, y: y@ (10 | 20 | 30) } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<ol start="3">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Message {
    Hello { id: i32 },
}

fn main() {
    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id:  id@3..=7,
        } =&gt; println!(&quot;Found an id in range [3, 7]: {}&quot;, id),
        Message::Hello { id: newid@(10 | 11 | 12) } =&gt; {
            println!(&quot;Found an id in another range [10, 12]: {}&quot;, newid)
        }
        Message::Hello { id } =&gt; println!(&quot;Found some other id: {}&quot;, id),
    }
}
</code></pre></pre>
<ol start="4">
<li>🌟🌟 A match guard is an additional if condition specified after the pattern in a match arm that must also match, along with the pattern matching, for that arm to be chosen.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let num = Some(4);
    let split = 5;
    match num {
        Some(x) if x != 0 =&gt; assert!(x &lt; split),
        Some(x) =&gt; assert!(x &gt;= split),
        None =&gt; (),
    }

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="5">
<li>🌟🌟 Ignoring remaining parts of the value with <code>..</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let numbers = (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048);

    match numbers {
        (first,..,last) =&gt; {
           assert_eq!(first, 2);
           assert_eq!(last, 2048);
        }
    }

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="6">
<li>🌟🌟 Using pattern <code>&amp;mut V</code> to match a mutable reference needs you to be very careful, due to <code>V</code> being a value  after matching.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut v = String::from(&quot;hello,&quot;);
    let r = &amp;mut v;

    match r {
        value =&gt; value.push_str(&quot; world!&quot;), // r is already a mutable borrow
    }

	// why can't we just do 
	// r.push_str(&quot; world!&quot;) 😆
	println!(&quot;{}&quot;, v);
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>

                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript" charset="utf-8">
        var pagePath = "print.md"
        </script>


        <!-- Custom JS scripts -->
        <script type="text/javascript" src="assets/custom3.js"></script>
        <script type="text/javascript" src="assets/lang.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>