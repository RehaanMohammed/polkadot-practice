<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust By Practice</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Learn Rust with Example, Exercise and real Practice, written with ‚ù§Ô∏è by https://course.rs team">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/style1.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');
                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }
                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="why-exercise.html"><strong aria-hidden="true">1.</strong> Rust By Practice</a></li><li class="chapter-item expanded "><a href="elegant-code-base.html"><strong aria-hidden="true">2.</strong> Small projects with Elegant code</a></li><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">3.</strong> First Assignment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="first-assignment/variables.html"><strong aria-hidden="true">3.1.</strong> Variables</a></li><li class="chapter-item expanded "><a href="first-assignment/basic-types/intro.html"><strong aria-hidden="true">3.2.</strong> Basic Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="first-assignment/basic-types/numbers.html"><strong aria-hidden="true">3.2.1.</strong> Numbers</a></li><li class="chapter-item expanded "><a href="first-assignment/basic-types/char-bool-unit.html"><strong aria-hidden="true">3.2.2.</strong> Char, Bool and Unit</a></li><li class="chapter-item expanded "><a href="first-assignment/basic-types/statements-expressions.html"><strong aria-hidden="true">3.2.3.</strong> Statements and Expressions</a></li><li class="chapter-item expanded "><a href="first-assignment/basic-types/functions.html"><strong aria-hidden="true">3.2.4.</strong> Functions</a></li></ol></li><li class="chapter-item expanded "><a href="first-assignment/ownership/intro.html"><strong aria-hidden="true">3.3.</strong> Ownership and Borrowing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="first-assignment/ownership/ownership.html"><strong aria-hidden="true">3.3.1.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="first-assignment/ownership/borrowing.html"><strong aria-hidden="true">3.3.2.</strong> Reference and Borrowing</a></li></ol></li><li class="chapter-item expanded "><a href="first-assignment/compound-types/intro.html"><strong aria-hidden="true">3.4.</strong> Compound Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="first-assignment/compound-types/string.html"><strong aria-hidden="true">3.4.1.</strong> string</a></li><li class="chapter-item expanded "><a href="first-assignment/compound-types/array.html"><strong aria-hidden="true">3.4.2.</strong> Array</a></li><li class="chapter-item expanded "><a href="first-assignment/compound-types/slice.html"><strong aria-hidden="true">3.4.3.</strong> Slice</a></li><li class="chapter-item expanded "><a href="first-assignment/compound-types/tuple.html"><strong aria-hidden="true">3.4.4.</strong> Tuple</a></li><li class="chapter-item expanded "><a href="first-assignment/compound-types/struct.html"><strong aria-hidden="true">3.4.5.</strong> Struct</a></li><li class="chapter-item expanded "><a href="first-assignment/compound-types/enum.html"><strong aria-hidden="true">3.4.6.</strong> Enum</a></li></ol></li><li class="chapter-item expanded "><a href="first-assignment/flow-control.html"><strong aria-hidden="true">3.5.</strong> Flow Control</a></li><li class="chapter-item expanded "><a href="first-assignment/pattern-match/intro.html"><strong aria-hidden="true">3.6.</strong> Pattern Match</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="first-assignment/pattern-match/match-iflet.html"><strong aria-hidden="true">3.6.1.</strong> match, matches! and if let</a></li><li class="chapter-item expanded "><a href="first-assignment/pattern-match/patterns.html"><strong aria-hidden="true">3.6.2.</strong> Patterns</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="second-assignment/intro.html"><strong aria-hidden="true">4.</strong> Second assignment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="second-assignment/method.html"><strong aria-hidden="true">4.1.</strong> Method & Associated function</a></li><li class="chapter-item expanded "><a href="second-assignment/generics-traits/intro.html"><strong aria-hidden="true">4.2.</strong> Generics and Traits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="second-assignment/generics-traits/generics.html"><strong aria-hidden="true">4.2.1.</strong> Generics</a></li><li class="chapter-item expanded "><a href="second-assignment/generics-traits/const-generics.html"><strong aria-hidden="true">4.2.2.</strong> Const Generics</a></li><li class="chapter-item expanded "><a href="second-assignment/generics-traits/traits.html"><strong aria-hidden="true">4.2.3.</strong> Traits</a></li><li class="chapter-item expanded "><a href="second-assignment/generics-traits/trait-object.html"><strong aria-hidden="true">4.2.4.</strong> Trait Object</a></li><li class="chapter-item expanded "><a href="second-assignment/generics-traits/advanced-traits.html"><strong aria-hidden="true">4.2.5.</strong> Advanced Traits</a></li></ol></li><li class="chapter-item expanded "><a href="second-assignment/collections/intro.html"><strong aria-hidden="true">4.3.</strong> Collection Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="second-assignment/collections/string.html"><strong aria-hidden="true">4.3.1.</strong> String</a></li><li class="chapter-item expanded "><a href="second-assignment/collections/vector.html"><strong aria-hidden="true">4.3.2.</strong> Vector</a></li><li class="chapter-item expanded "><a href="second-assignment/collections/hashmap.html"><strong aria-hidden="true">4.3.3.</strong> HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="second-assignment/type-conversions/intro.html"><strong aria-hidden="true">4.4.</strong> Type Conversion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="second-assignment/type-conversions/as.html"><strong aria-hidden="true">4.4.1.</strong> as</a></li><li class="chapter-item expanded "><a href="second-assignment/type-conversions/from-into.html"><strong aria-hidden="true">4.4.2.</strong> From/Into</a></li><li class="chapter-item expanded "><a href="second-assignment/type-conversions/others.html"><strong aria-hidden="true">4.4.3.</strong> Others</a></li></ol></li><li class="chapter-item expanded "><a href="second-assignment/result-panic/intro.html"><strong aria-hidden="true">4.5.</strong> Result and panic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="second-assignment/result-panic/panic.html"><strong aria-hidden="true">4.5.1.</strong> panic!</a></li><li class="chapter-item expanded "><a href="second-assignment/result-panic/result.html"><strong aria-hidden="true">4.5.2.</strong> Result and ?</a></li></ol></li><li class="chapter-item expanded "><a href="second-assignment/crate-module/intro.html"><strong aria-hidden="true">4.6.</strong> Crate and Module</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="second-assignment/crate-module/crate.html"><strong aria-hidden="true">4.6.1.</strong> Package and Crate</a></li><li class="chapter-item expanded "><a href="second-assignment/crate-module/module.html"><strong aria-hidden="true">4.6.2.</strong> Module</a></li><li class="chapter-item expanded "><a href="second-assignment/crate-module/use-pub.html"><strong aria-hidden="true">4.6.3.</strong> Advanced use and pub</a></li></ol></li><li class="chapter-item expanded "><a href="second-assignment/comments_docs/src/comments-docs.html"><strong aria-hidden="true">4.7.</strong> Comments and Docs</a></li><li class="chapter-item expanded "><a href="second-assignment/formatted-output/intro.html"><strong aria-hidden="true">4.8.</strong> Formatted output</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="second-assignment/formatted-output/println.html"><strong aria-hidden="true">4.8.1.</strong> println! and format!</a></li><li class="chapter-item expanded "><a href="second-assignment/formatted-output/debug-display.html"><strong aria-hidden="true">4.8.2.</strong> Debug and Display</a></li><li class="chapter-item expanded "><a href="second-assignment/formatted-output/formatting.html"><strong aria-hidden="true">4.8.3.</strong> formating</a></li></ol></li><li class="chapter-item expanded "><a href="second-assignment/functional-programing/intro.html"><strong aria-hidden="true">4.9.</strong> Functional programing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="second-assignment/functional-programing/cloure.html"><strong aria-hidden="true">4.9.1.</strong> Closure</a></li><li class="chapter-item expanded "><a href="second-assignment/functional-programing/iterator.html"><strong aria-hidden="true">4.9.2.</strong> Iterator</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust By Practice</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sunface/rust-by-practice" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <div align="center">
    <img  src="https://github.com/sunface/rust-by-practice/blob/master/en/assets/header.png?raw=true">
</div>
<p align="center">Practice Rust with challenging examples, exercises and projects</p>
<div align="center">
<p><a href="https://github.com/sunface/rust-by-practice/stargazers"><img src="https://img.shields.io/github/stars/sunface/rust-by-practice?style=flat" alt="Stars Count" /></a> <a href="https://github.com/naaive/orange/network/members"><img src="https://img.shields.io/github/forks/sunface/rust-by-practice.svg?style=flat" alt="Forks Count" /></a>
<a href="https://github.com/sunface/rust-by-practice/blob/master/LICENSE"><img src="https://img.shields.io/badge/license-mit-green?style=flat" alt="LICENSE" /></a></p>
</div>
<p>This book was designed for easily diving into and get skilled with Rust, and it's very easy to use: All you need to do is to make each exercise compile without ERRORS and Panics !</p>
<h2 id="reading-online"><a class="header" href="#reading-online">Reading online</a></h2>
<ul>
<li><a href="https://practice.rs">English</a></li>
<li><a href="https://zh.practice.rs">ÁÆÄ‰Ωì‰∏≠Êñá</a></li>
</ul>
<h2 id="running-locally"><a class="header" href="#running-locally">Running locally</a></h2>
<p>We use <a href="https://rust-lang.github.io/mdBook/">mdbook</a> building our exercises. You can run locally with below steps:</p>
<pre><code class="language-shell">$ cargo install mdbook
$ cd rust-by-practice &amp;&amp; mdbook serve 
</code></pre>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<p>Part of our examples and exercises are borrowed from <a href="https://github.com/rust-lang/rust-by-example">Rust By Example</a>, thanks for your great works!</p>
<p>Although they are so awesome, we have our own secret weapons :)</p>
<ul>
<li>
<p>There are three parts in each chapter: examples, exercises and practices</p>
</li>
<li>
<p>Besides examples, we have <code>a lot of exercises</code>, you can Read, Edit and Run them ONLINE</p>
</li>
<li>
<p>Covering nearly all aspects of Rust, such as async/await, threads, sync primitives, optimizing, standard libraries, tool chain, data structures and algorithms etc.</p>
</li>
<li>
<p>Every exercise has its own solutions</p>
</li>
<li>
<p>The overall difficulties are a bit higher and from easy to super hard: easy üåü medium üåüüåü hard üåüüåüüåü super hard üåüüåüüåüüåü</p>
</li>
</ul>
<p><strong>What we want to do is fill in the gap between learning and getting started with real projects.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="small-projects-with-elegant-code-base"><a class="header" href="#small-projects-with-elegant-code-base">Small projects with Elegant code base</a></h1>
<p>Following questions come up weekly in online Rust discussions: </p>
<ul>
<li>I just finished reading The Book, what should I do next ?</li>
<li>What projects would you recommend to a Rust beginner?</li>
<li>Looking for small projects with an elegant code base</li>
<li>Codes that is easy to read and learn</li>
</ul>
<p>The answers to these questions are always <strong>Practice</strong>: doing some exercises, and then reading some small and excellent Rust projects.</p>
<p>This is precisely the goal of this book, so, collecting relative resourses and representing in <em>Rust By Practice</em> seems not a bad idea.</p>
<h3 id="1-ripgrep"><a class="header" href="#1-ripgrep">1. Ripgrep</a></h3>
<p>Answers for above questions usually came with <a href="https://github.com/BurntSushi/ripgrep"><code>ripgrep</code></a>, though I don't think it is a <strong>small</strong> project, but yes, go for it if you are not afraid to delve deep a bit.</p>
<h3 id="2-building-a-text-editor"><a class="header" href="#2-building-a-text-editor">2. Building a text editor</a></h3>
<p>Tutorial <a href="https://www.philippflenker.com/hecto/"><code>https://www.philippflenker.com/hecto/</code></a> will lead you to build a text editor from scratch.</p>
<h3 id="3-ncspot"><a class="header" href="#3-ncspot">3. Ncspot</a></h3>
<p><a href="https://github.com/hrkfdn/ncspot">Ncspot</a>, a terminal Spotify client. Small, simple, well organized and async, it's good for learning.</p>
<h3 id="4-command-line-rust"><a class="header" href="#4-command-line-rust">4. Command Line Rust</a></h3>
<p><a href="https://github.com/kyclark/command-line-rust">This project</a> is for the book <code>Command-Line Rust(O'Reily)</code> ,it will show you how to write small CLIS( clones of head, cat, ls).</p>
<h3 id="5-pngme-book"><a class="header" href="#5-pngme-book">5. pngme book</a></h3>
<p><a href="https://picklenerd.github.io/pngme_book/">This book</a> will guide you to make a command line program that lets you hide secret messages in PNG files.  The primary goal here is to get you writing code. The secondary goal is to get you reading documentation.</p>
<h3 id="6-writing-an-os-in-rust"><a class="header" href="#6-writing-an-os-in-rust">6. Writing an OS in Rust</a></h3>
<p><a href="https://os.phil-opp.com">This blog series</a> creates a small operating system in the Rust programming language. Each post is a small tutorial and includes all needed code, so you can follow along if you like. The source code is also available in the corresponding <a href="https://github.com/phil-opp/blog_os">Github repository</a>.</p>
<h3 id="7-codecraftersio-build-your-own-git-docker-sqlite-or-redis"><a class="header" href="#7-codecraftersio-build-your-own-git-docker-sqlite-or-redis">7. CodeCrafters.io: Build your own Git, Docker, SQLite, or Redis</a></h3>
<p>On <a href="https://codecrafters.io/for/rust">CodeCrafters</a>, you can recreate your favorite developer tools from scratch. It's a hands-on, minimally-guided approach to master Rust, while appreciating the internals and documentation of popular technology that we use every day.</p>
<h3 id="8-mini-redis"><a class="header" href="#8-mini-redis">8. mini-redis</a></h3>
<p><a href="https://github.com/tokio-rs/mini-redis">mini-redis</a> is an incomplete Redis client and server implementation using tokio, it has decent code base and detail explanations, very suitable for learning Rust and asynchronous programming.</p>
<hr />
<p><strong>To be continued...</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-first-assignment"><a class="header" href="#the-first-assignment">The first Assignment.</a></h1>
<p>I am  going to be practicing.</p>
<ol>
<li>Variables</li>
<li>Basic Data types</li>
<li>Compound Data types</li>
<li>Flow control</li>
<li>Pattern match</li>
<li>Ownership</li>
</ol>
<p>Hope you like it.</p>
<blockquote>
<p>note: Constructive comment/criticism is welcomed in the comments.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<h3 id="binding-and-mutability"><a class="header" href="#binding-and-mutability">Binding and mutability</a></h3>
<ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x: i32 = 5; // Uninitialized but used, ERROR !

//Every variable must be initialized before using. duh... 

    let _y: i32; // Uninitialized but also unused, only a Warning !

// The convention is to add '_' before identifiers if you are not going to use them

    assert_eq!(x, 5);
    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut x = 1;
    x += 2; 

// Variables are immutable by default
    
    assert_eq!(x, 3);
    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="scope"><a class="header" href="#scope">Scope</a></h3>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x: i32 = 10;
//  {

    let y: i32 = 5;
    println!(&quot;The value of x is {} and value of y is {}&quot;, x, y);
    
//  } if braces were enabled then the variable 'y' will be destroyed here 

// Easiest way would be to change the scope of the variable.

    println!(&quot;The value of x is {} and value of y is {}&quot;, x, y); 
}
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
// add function call to &quot;define_x&quot;
    println!(&quot;{}, world&quot;, define_x()); 
}

// Here &quot;'a&quot; is the lifetime parameter defined for the string that is returned
// This helps rust to identify the lifetime of a string variable so that the 
// compiler can safely destroy the string after it's lifetime is completed.
// In this example the lifetime &quot;'a&quot; is bound to the function call &quot;define_x&quot;
// after the function call, the string will be destroyed.

fn define_x&lt;'a&gt;() -&gt; &amp;'a str {
// Returning &amp;str
    &quot;hello&quot;
}
</code></pre></pre>
<h3 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h3>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x: i32 = 5;
    {
// Here the variable x holds the value &quot;12&quot; in this scope
        let x = 12;
        assert_eq!(x, 12);
    }

// Here the value is &quot;5&quot; in this scope
    assert_eq!(x, 5);

    let x = 42;
    println!(&quot;{}&quot;, x); // Prints &quot;42&quot;.
}
</code></pre></pre>
<ol start="6">
<li>üåüüåü </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut _x: i32 = 1;
    _x = 7;
    // Shadowing and re-binding
    {
    // Shadowing must be done in a new scope
    let mut _x = _x; // add &quot;mut&quot; if you're going to mutate
    _x += 3;
    
    }

    let _y = 4;
    // Shadowing
    {
    
    let _y = &quot;I can also be bound to text!&quot;; 
    
    }
    
    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="unused-variables"><a class="header" href="#unused-variables">Unused variables</a></h3>
<ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[allow(unused_variables)] // 1) Allow unused variable
fn main() {
    let _x = 1; // 2) The convention is to add &quot;_&quot; before an unused variable 
}

// Warning: unused variable: `x`
</code></pre></pre>
<h3 id="destructuring"><a class="header" href="#destructuring">Destructuring</a></h3>
<ol start="8">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let (mut x, y) = (1, 2);
    x += 2;

// Make 'x' mutable

    assert_eq!(x, 3);
    assert_eq!(y, 2);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="destructuring-assignments"><a class="header" href="#destructuring-assignments">Destructuring assignments</a></h3>
<ol start="9">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let (x, y);
    (x,..) = (3, 4);// 3 is assigned to x
    [.., y] = [1, 2];// 2 is assigned to y
// (x,...) is checked with (3, 4)

    assert_eq!([x,y], [3, 2]);

    println!(&quot;Success!&quot;);
} 
</code></pre></pre>
<pre><code class="language-ignore">    ----------
   |          |
   |    ---------
   |   |      |  |
   |   |      v  v
  (x, ...) = (3, 4); The &quot;...&quot; is ignored.

 Similarly,

    ---------
   |         |
   |    --------
   |   |     |  |
   |   |     v  v 
 [..., y] = [1, 2];

Hence, x = 3 and y = 2

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-types"><a class="header" href="#basic-types">Basic Types</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch03-02-data-types.html">Rust Book 3.2 and 3.3</a></li>
<li>ÁÆÄ‰Ωì‰∏≠Êñá: <a href="https://course.rs/basic/base-type/index.html">RustËØ≠Ë®ÄÂú£Áªè - Âü∫Êú¨Á±ªÂûã</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numbers"><a class="header" href="#numbers">Numbers</a></h1>
<h3 id="integer"><a class="header" href="#integer">Integer</a></h3>
<ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x: i32 = 5;
    let mut y: i32 = 5; // make U32 to I32 so that the types of x and y can match

    y = x;
    
    let z = 10; // any unconstrained integer will default to type {Integer} which is i32.

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let v: u16 = 38_u8 as u16; // &quot;as&quot; keyword is used for explicit type conversion

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = 5;
    assert_eq!(&quot;i32&quot;.to_string(), type_of(&amp;x)); // Integer is defaulted to i32 when type is not assigned explicitly.

    println!(&quot;Success!&quot;);
}

// Get the type of given variable, return a string representation of the type  , e.g &quot;i8&quot;, &quot;u8&quot;, &quot;i32&quot;, &quot;u32&quot;
fn type_of&lt;T&gt;(_: &amp;T) -&gt; String {
    format!(&quot;{}&quot;, std::any::type_name::&lt;T&gt;())
}
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    assert_eq!(i8::MAX, 127); // The range is from -128 to 127 
    assert_eq!(u8::MAX, 255); // The range is from 0 to 255

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
   let v1 = 251_u16 + 8; // converting to u16 to increase the range
   if let Some(v2) = u8::checked_add(251, 8) {
       println!(&quot;{},{}&quot;,v1,v2);
   } else {
       println!(&quot;The sum will be out of range of \'u8\'.\nHence we cannot add \'8\' to it.&quot;);
   }
}
</code></pre></pre>
<ol start="6">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let v = 1_024 /* decimal 1024 */ + 0xff /* hexa decimal 255*/ + 0o77 /* octal 63 */ + 0b1111_1111 /* binary 255 */;
    
    assert!(v == 1597);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="floating-point"><a class="header" href="#floating-point">Floating-Point</a></h3>
<ol start="7">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = 1_000.000_1 // f64 is default
    let y: f32 = 0.12; // f32
    let z = 0.01_f64; // f64 

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="8">
<li></li>
</ol>
<p>I remember seeing this <a href="https://www.youtube.com/shorts/s9F8pu5KfyM">video</a> on YouTube that explained why computers suck at math because of rounding error.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 1) Using rounding function.

fn main() {
    
    assert!(0.1_f32.round() + 0.2_f32.round() == 0.3_f32.round());

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 2) Using absolute values

fn main() {
    
    assert!(0.1_f32.abs() + 0.2_f32.abs() == 0.3_f32.abs());

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="range"><a class="header" href="#range">Range</a></h3>
<ol start="9">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut sum = 0;
    for i in -3..2 {
        sum += i
    }

    assert!(sum == -5); // Refer below

    for c in 'a'..='z' {
        println!(&quot;{}&quot;,c as u8); // explicit conversion to u8
    }
}
</code></pre></pre>
<div class="table-wrapper"><table><thead><tr><th>Iter</th><th>Variables</th><th>Computation</th></tr></thead><tbody>
<tr><td>iter1</td><td>i =	-3	sum =	00</td><td>0 + (-3)</td></tr>
<tr><td>iter2</td><td>i =	-2	sum =	-3</td><td>-3 - 2</td></tr>
<tr><td>iter3</td><td>i =	-1	sum =	-5</td><td>-5 - 1</td></tr>
<tr><td>iter4</td><td>i =	0	sum =	-6</td><td>-6 + 0</td></tr>
<tr><td>iter5</td><td>i =	1	sum =	-6</td><td>-6 + 1</td></tr>
<tr><td>iter6</td><td>i =	2	sum =	-5</td><td>break;</td></tr>
</tbody></table>
</div>
<ol start="10">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::ops::{Range, RangeInclusive};
fn main() {
    assert_eq!((1..5), Range{ start: 1, end: 5 });
    assert_eq!((1..=5), RangeInclusive::new(1, 5));

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="computations"><a class="header" href="#computations">Computations</a></h3>
<ol start="11">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // Integer addition
    assert!(1u32 + 2 == 3);

    // Integer subtraction
    assert!(1i32 - 2 == -1);
    assert!(1i8 - 2 == -1); // change to i8 as negative values are out of range 
    
    assert!(3 * 50 == 150);

    assert!(9.6_f32.abs() / 3.2_f32.abs() == 3.0); // Use absolute values

    assert!(24 % 5 == 4);
    // Short-circuiting boolean logic
    assert!(true &amp;&amp; false == false);
    assert!(true || false == true);
    assert!(!true == false);

    // Bitwise operations
    println!(&quot;0011 AND 0101 is {:04b}&quot;, 0b0011u32 &amp; 0b0101);
    println!(&quot;0011 OR 0101 is {:04b}&quot;, 0b0011u32 | 0b0101);
    println!(&quot;0011 XOR 0101 is {:04b}&quot;, 0b0011u32 ^ 0b0101);
    println!(&quot;1 &lt;&lt; 5 is {}&quot;, 1u32 &lt;&lt; 5);
    println!(&quot;0x80 &gt;&gt; 2 is 0x{:x}&quot;, 0x80u32 &gt;&gt; 2);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="char-bool-and-unit"><a class="header" href="#char-bool-and-unit">Char, Bool and Unit</a></h1>
<h3 id="char"><a class="header" href="#char">Char</a></h3>
<ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">use std::mem::size_of_val;
fn main() {
    let c1 = 'a';
    assert_eq!(size_of_val(&amp;c1),4); // char is 4 bytes 

    let c2 = '‰∏≠';
    assert_eq!(size_of_val(&amp;c2),4); // similarly this is also 4 bytes.

    println!(&quot;Success!&quot;);
} 
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let c1 = '‰∏≠';

// Single quotes is for character and double quotes is for strings.
// This ain't Python. We have proper standards and conventions.

    print_char(c1);
} 

fn print_char(c : char) {
    println!(&quot;{}&quot;, c);
}
</code></pre></pre>
<h3 id="bool"><a class="header" href="#bool">Bool</a></h3>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let f: bool = false;

    let t = f;

// Could've just removed the bang but, I guessed we had to use the unused variable.

    if !t {
        println!(&quot;Success!&quot;);
    }
} 
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let f = true;
    let t = true || false;
    assert_eq!(t, f);

    println!(&quot;Success!&quot;);
}

</code></pre></pre>
<p>AND truth table:</p>
<div class="table-wrapper"><table><thead><tr><th>X</th><th>Y</th><th>X&amp;Y</th></tr></thead><tbody>
<tr><td>true</td><td>false</td><td>false</td></tr>
<tr><td>false</td><td>true</td><td>false</td></tr>
<tr><td>false</td><td>false</td><td>false</td></tr>
<tr><td>true</td><td>true</td><td>true</td></tr>
</tbody></table>
</div>
<h3 id="unit-type"><a class="header" href="#unit-type">Unit type</a></h3>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let w: () = ();

    let v = (2, 3);
    assert_eq!(w, implicitly_ret_unit()); // I can't think of anything but changing the variable name

    println!(&quot;Success!&quot;);
}

fn implicitly_ret_unit() {
    println!(&quot;I will return a ()&quot;);
}

fn explicitly_ret_unit() -&gt; () {
    println!(&quot;I will return a ()&quot;);
}
</code></pre></pre>
<ol start="6">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::mem::size_of_val;
fn main() {
    let unit: () = ();
    assert!(size_of_val(&amp;unit) == 0); // size of unit type is zero

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="statements-and-expressions"><a class="header" href="#statements-and-expressions">Statements and Expressions</a></h1>
<ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 1) 
fn main() {
   let v = {
       let mut x = 1;
       x += 2;
       x
   };

   assert_eq!(v, 3);

   println!(&quot;Success!&quot;);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 2)
fn main() {
   let v = {
       let mut x = 1;
       x + 2
   };

   assert_eq!(v, 3);

   println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
   let v = {let x = 3; x}; // Paranthesis can only be used for tuples.
// There should also be a return statement otherwise the expression will return ()
   assert!(v == 3);

   println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = sum(1 , 2);
    assert_eq!(s, 3);

    println!(&quot;Success!&quot;);
}

// semicolon means the statement is not returning instead () is returned
fn sum(x: i32, y: i32) -&gt; i32 {
    x + y
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let (x, y) = (1, 2);
    let s = sum(x, y);

    assert_eq!(s, 3);

    println!(&quot;Success!&quot;);
}

// Each argument type must be declared because, rust hates ambiguity at run time.
fn sum(x: i32, y: i32) -&gt; i32 { // add a return type and remove semicolons to return expression
    x + y
}
</code></pre></pre>
<ol start="2">
<li>üåü</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
   print();
}

fn print() -&gt; () { // No need to specify () just keeping it blank will suffice
   println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 1) Using panic to stop a program abruptly
#[allow(unreachable_code)]
fn main() {
    never_return();

    println!(&quot;Failed!&quot;);
}

fn never_return() -&gt; ! {
   panic!(); 
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 2) Using never ending loop.
// This should never be used in real code.
#[allow(unreachable_code)]
fn main() {
    never_return();

    println!(&quot;Failed!&quot;);
}

fn never_return() -&gt; ! {
   loop{}
}
</code></pre></pre>
<h3 id="diverging-functions"><a class="header" href="#diverging-functions">Diverging functions</a></h3>
<p>Diverging functions never return to the caller, so they may be used in places where a value of any type is expected.</p>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!(&quot;Success!&quot;);
}

fn get_option(tp: u8) -&gt; Option&lt;i32&gt; {
    match tp {
        1 =&gt; {
            // TODO
        }
        _ =&gt; {
            // TODO
        }
    };
    
    never_return_fn()
}

// IMPLEMENT this function in THREE ways
// 1)
fn never_return_fn() -&gt; ! {
    panic!();
}

// 2)

// fn never_return_fn() -&gt; ! {
//     loop{}
// }

// 3)

// fn never_return_fn() -&gt; ! {
//     std::process::exit(1);
// }
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let b = false;

    let v = match b {
        true =&gt; 1,
        false =&gt; {
            println!(&quot;Success!&quot;);
            panic!(&quot;we have no value for `false`, but we can panic&quot;);
        }
    };

    println!(&quot;Exercise Failed if printing out this line!&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-and-borrowing"><a class="header" href="#ownership-and-borrowing">Ownership and Borrowing</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">Rust Book 4.1-4.4</a></li>
<li>ÁÆÄ‰Ωì‰∏≠Êñá: <a href="https://course.rs/basic/ownership/index.html">RustËØ≠Ë®ÄÂú£Áªè - ÊâÄÊúâÊùÉ‰∏éÂÄüÁî®</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 1)
fn main() {
    let x = String::from(&quot;hello, world&quot;);
    let y = x.clone();
    println!(&quot;{},{}&quot;,x,y);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 2)
fn main() {
    // using string slices.
    let x = String::from(&quot;hello, world&quot;);
    let y = &amp;x[..];
    println!(&quot;{},{}&quot;,x,y);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 3)
fn main() {
    // using &amp;String
    let x = &amp;String::from(&quot;hello, world&quot;);
    let y = x;
    println!(&quot;{},{}&quot;,x,y);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 4)
fn main() {
    // Storing &amp;str and copying that
    let x = &quot;hello, world&quot;;
    let y = x;
    println!(&quot;{},{}&quot;,x,y);
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s1 = String::from(&quot;hello, world&quot;);
    let s2 = take_ownership(s1);

    println!(&quot;{}&quot;, s2);
}

fn take_ownership(s: String) -&gt; String {
    println!(&quot;{}&quot;, s);
    s // Temporarily s owns it but the owership is returned to s2
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = give_ownership();
    println!(&quot;{}&quot;, s);
}

fn give_ownership() -&gt; String {
    let s = String::from(&quot;hello, world&quot;);
    // Convert String to Vec
    let _s = s.into_bytes(); // _s owns the string now
    String::from_utf8_lossy(&amp;_s).to_string() // Converting bytes to String

// Here to_string() is required as the type is actually a Cow
// Which basically is a type that holds a smart pointer that provides cloning when borrowed.
}
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = String::from(&quot;hello, world&quot;);

    print_str(&amp;s[..]);

    println!(&quot;{}&quot;, s);
}

fn print_str(s: &amp;str)  {
    println!(&quot;{}&quot;,s)
}

// You can also do this: 
// fn main() {
//     let mut s = String::from(&quot;hello, world&quot;);
// 
//     s = print_str(s);
// 
//     println!(&quot;{}&quot;, s);
// }
// 
// fn print_str(s: String) -&gt; String {
//     println!(&quot;{}&quot;,s);
//     s
// }
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let x = (1, 2, (), &quot;hello&quot;);
    let y = x;
    println!(&quot;{:?}, {:?}&quot;, x, y);
}
</code></pre></pre>
<pre><code class="language-ignore">Why ownership in rust is an important concept:

* Rust doesn't have a garbage collector.
* Instead all the variables are dropped when they leave the scope much like c.
* This then poses a problem with pointers. First we have to understand how strings work.

What is a string?
=================

A string is a series of char with a pointer to the first char
stored in variable and a '\0' delimiter to denote end of the string.

example in c:
       ----                 -----
      |  &amp; |               |     |
      |    v               |     v
char* s = &quot;Rust is awesome!&quot;;   '\0' is appended

s holds the address of the char 'R'. Hence, s++ would be 'u'.

So when you something like

char* s1 = s; Here s1 is also a pointer that holds the address of 'R'.

In rust, because of the drop trait that is applied to the variables, at the end of the variable scope,

Now you have 2 pointers pointing to the same data.
If the rust compiler follows through and deletes the pointer and frees the memory it was pointing to,
Then the compiler will delete whatever else memory that the dangling pointer is pointing to.

This all can be solved by using ownership which basically just allows one pointer at a time to memory. Rust borrow-checker will
check the code and keep track of who the owner is at a given point in the code.
</code></pre>
<h4 id="handling-assignments-and-a-full-time-job-is-difficult-i-havent-slept-since-2-days-"><a class="header" href="#handling-assignments-and-a-full-time-job-is-difficult-i-havent-slept-since-2-days-">Handling assignments and a full time job is DIFFICULT. I haven't slept since 2 days ...</a></h4>
<iframe src="https://giphy.com/embed/D12CsrRNv7gL6" width="480" height="360" frameBorder="0" class="giphy-embed"></iframe><p><a href="https://giphy.com/gifs/crazy-family-guy-lol-D12CsrRNv7gL6"></a></p>
<h4 id="mutability"><a class="header" href="#mutability">Mutability</a></h4>
<ol start="6">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = String::from(&quot;hello, &quot;);
    
    let mut s1 = s;

    s1.push_str(&quot;world&quot;);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="7">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = Box::new(5);
    
    let mut y = Box::new(420);
    
    *y = 4;
    
    assert_eq!(*x, 5);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="partial-move"><a class="header" href="#partial-move">Partial move</a></h3>
<h4 id="exercises"><a class="header" href="#exercises">Exercises</a></h4>
<ol start="8">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
   let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;));

   let _s = t.0;

   println!(&quot;{:?}&quot;, t.1); // since t.0 is borrowed we can only use t.1
}
</code></pre></pre>
<ol start="9">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
   let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;));

    let (s1, s2) = t.clone();

    println!(&quot;{:?}, {:?}, {:?}&quot;, s1, s2, t); // -&gt; &quot;hello&quot;, &quot;world&quot;, (&quot;hello&quot;, &quot;world&quot;)
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-and-borrowing"><a class="header" href="#reference-and-borrowing">Reference and Borrowing</a></h1>
<h3 id="reference"><a class="header" href="#reference">Reference</a></h3>
<ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
   let x = 5;
   let p = &amp;x;

   println!(&quot;the memory address of x is {:p}&quot;, p); // One possible output: 0x16fa3ac84
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, *y);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    borrow_object(&amp;s); // argument expects &amp;string

    println!(&quot;Success!&quot;);
}

fn borrow_object(s: &amp;String) {}
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    push_str(&amp;mut s); // Sending mutable reference

    println!(&quot;Success!&quot;);
}

fn push_str(s: &amp;mut String) {
    s.push_str(&quot;world&quot;)
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    let p = &amp;mut s;
    
    p.push_str(&quot;world&quot;);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h4 id="ref"><a class="header" href="#ref">Ref</a></h4>
<p><code>ref</code> can be used to take references to a value, similar to <code>&amp;</code>.</p>
<ol start="6">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let c = '‰∏≠';

    let r1 = &amp;c;
    let ref r2 = c; // ref type makes working with addresses and pointers a little safer.

    assert_eq!(*r1, *r2);
    
    assert_eq!(get_addr(r1),get_addr(r2));

    println!(&quot;Success!&quot;);
}

// Get memory address string
fn get_addr(r: &amp;char) -&gt; String {
    format!(&quot;{:p}&quot;, r)
}
</code></pre></pre>
<h3 id="borrowing-rules"><a class="header" href="#borrowing-rules">Borrowing rules</a></h3>
<ol start="7">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s;
    let r2 = &amp;s; // no need to mutate

    println!(&quot;{}, {}&quot;, r1, r2);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h4 id="mutability-1"><a class="header" href="#mutability-1">Mutability</a></h4>
<ol start="8">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s = String::from(&quot;hello, &quot;); //  cannot be mutated if the original variable ain't mutable.

    borrow_object(&amp;mut s);

    println!(&quot;Success!&quot;);
}

fn borrow_object(s: &amp;mut String) {}
</code></pre></pre>
<ol start="9">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">    let mut s = String::from(&quot;hello, &quot;);

    borrow_object(&amp;s);
    
    s.push_str(&quot;world&quot;);

    println!(&quot;Success!&quot;);
}

fn borrow_object(s: &amp;String) {}
</code></pre></pre>
<h3 id="nll"><a class="header" href="#nll">NLL</a></h3>
<ol start="10">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    let r1 = &amp;mut s;
    r1.push_str(&quot;world&quot;);
    let r2 = &amp;mut s;
    r2.push_str(&quot;!&quot;);
    
    // println!(&quot;{}&quot;,r1); cause s is borrowed to r2 now
}
</code></pre></pre>
<ol start="11">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    // You can't use r1 and r2 at the same time
	
    r1.push_str(r2);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch04-03-slices.html">Rust Book 4.3, 5.1, 6.1, 8.2</a></li>
<li>ÁÆÄ‰Ωì‰∏≠Êñá: <a href="https://course.rs/basic/compound-type/intro.html">RustËØ≠Ë®ÄÂú£Áªè - Â§çÂêàÁ±ªÂûã</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">String</a></h1>
<h3 id="str-and-str"><a class="header" href="#str-and-str">Str and &amp;str</a></h3>
<ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s: &amp;str = &quot;hello, world&quot;; // it is &amp;str not str

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s: Box&lt;str&gt; = &quot;hello, world&quot;.into();
    greetings(&amp;s);
}

fn greetings(s: &amp;str) {
    println!(&quot;{}&quot;,s)
}
</code></pre></pre>
<h3 id="string-1"><a class="header" href="#string-1">String</a></h3>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let mut s = String::new();
    s.push_str(&quot;hello, world&quot;);
    s.push('!');

    assert_eq!(s, &quot;hello, world!&quot;);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s = String::from(&quot;hello&quot;);
    s.push(',');
    s.push_str(&quot; world&quot;);
    s += &quot;!&quot;;

    println!(&quot;{}&quot;, s);
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = String::from(&quot;I like dogs&quot;);
    let s1 = s.replace(&quot;dogs&quot;, &quot;cats&quot;);

    assert_eq!(s1, &quot;I like cats&quot;);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="6">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s1 = String::from(&quot;hello,&quot;);
    let s2 = String::from(&quot;world!&quot;);
    let s3 = s1.clone() + &amp;s2; 
    assert_eq!(s3,&quot;hello,world!&quot;);
    println!(&quot;{}&quot;,s1);
}
</code></pre></pre>
<h3 id="str-and-string"><a class="header" href="#str-and-string">&amp;str and String</a></h3>
<ol start="7">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 1)
fn main() {
    let s = String::from(&quot;hello, world&quot;);
    greetings(s);
}

fn greetings(s: String) {
    println!(&quot;{}&quot;,s)
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 2)
fn main() {
    let s = &quot;hello, world&quot;.to_string();
    greetings(s);
}

fn greetings(s: String) {
    println!(&quot;{}&quot;,s)
}
</code></pre></pre>
<ol start="8">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = &quot;hello, world&quot;.to_string();
    let s1: &amp;str = &amp;s[..];

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="string-escapes"><a class="header" href="#string-escapes">String escapes</a></h3>
<ol start="9">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let byte_escape = &quot;I'm writing Ru\x73__!&quot;;
    println!(&quot;What are you doing\x3F (\\x3F means ?) {}&quot;, byte_escape);

    let unicode_codepoint = &quot;\u{211D}&quot;;
    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;

    println!(&quot;Unicode character {} (U+211D) is called {}&quot;,
                unicode_codepoint, character_name );

   let long_string = &quot;String literals
                        can span multiple lines.
                        The linebreak and indentation here \
                         can be escaped too!&quot;;
    println!(&quot;{}&quot;, long_string);
}
</code></pre></pre>
<ol start="10">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let raw_str = &quot;Escapes don't work here: \x3F \u{211D}&quot;;
    assert_eq!(raw_str, &quot;Escapes don't work here: ? ‚Ñù&quot;);

    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;
    println!(&quot;{}&quot;, quotes);

    let  delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;
    println!(&quot;{}&quot;, delimiter);

    let long_delimiter = r###&quot;Hello, &quot;##&quot;&quot;###;
    assert_eq!(long_delimiter, &quot;Hello, \&quot;##\&quot;&quot;);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="string-index"><a class="header" href="#string-index">String index</a></h3>
<ol start="11">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s1 = String::from(&quot;hi,‰∏≠ÂõΩ&quot;);
    let h = s1[0..1]; // h is only one byte 
    assert_eq!(h, &quot;h&quot;);

    let h1 = &amp;s1[3..6]; // the symbol '‰∏≠' is 2 bytes long
    assert_eq!(h1, &quot;‰∏≠&quot;);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="operate-on-utf8-string"><a class="header" href="#operate-on-utf8-string">Operate on UTF8 string</a></h3>
<ol start="12">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    for c in &quot;‰Ω†Â•ΩÔºå‰∏ñÁïå&quot;.chars() {
// chars() creates iterator of chars
        println!(&quot;{}&quot;, c)
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array"><a class="header" href="#array">Array</a></h1>
<ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let arr: [u8; 5] = [1, 2, 3, 4, 5];

    assert!(arr.len() == 5);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let arr0 = [1, 2, 3];
    let arr: [char; 3] = ['a', 'b', 'c'];
    
    // Fill the blank
    // Arrays are stack allocated, `std::mem::size_of_val` returns the bytes which an array occupies
    // A char takes 4 bytes in Rust: Unicode char
    assert!(std::mem::size_of_val(&amp;arr) == 12); // cause 4 x 3 = 12 quik mafs

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let list: [i32; 100] = [1; 100];

    assert!(list[0] == 1);
    assert!(list.len() == 100);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let _arr = [1, 2, 3];// array are homogenous unlike tuples

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let arr = ['a', 'b', 'c'];
    
    let ele = arr[0];

    assert!(ele == 'a');

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="6">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let names = [String::from(&quot;Sunfei&quot;), &quot;Sunface&quot;.to_string()];
    
    let name0 = names.get(0).unwrap();

    let _name1 = &amp;names[1];

    println!(&quot;Success!&quot;);
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slice"><a class="header" href="#slice">Slice</a></h1>
<ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let arr = [1, 2, 3];
    let s1: &amp;[i32] = &amp;arr[0..2];

    let s2: &amp;str = &quot;hello, world&quot;;

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let arr: [char; 3] = ['‰∏≠', 'ÂõΩ', '‰∫∫'];

    let slice = &amp;arr[..2];
    
    assert!(std::mem::size_of_val(&amp;slice) == 16);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let arr: [i32; 5] = [1, 2, 3, 4, 5];
    let slice: &amp;[i32] = &amp;arr[1..4];
    assert_eq!(slice, &amp;[2, 3, 4]);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="string-slices"><a class="header" href="#string-slices">String slices</a></h3>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = String::from(&quot;hello&quot;);

    let slice1 = &amp;s[0..2];
    let slice2 = &amp;s[..2];

    assert_eq!(slice1, slice2);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = &quot;‰Ω†Â•ΩÔºå‰∏ñÁïå&quot;;
    let slice = &amp;s[0..3];

    assert!(slice == &quot;‰Ω†&quot;);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="6">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    println!(&quot;the first word is: {}&quot;, word);
    
    s.clear();

}
fn first_word(s: &amp;str) -&gt; &amp;str {
    &amp;s[..1]
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuple"><a class="header" href="#tuple">Tuple</a></h1>
<ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let _t0: (u8,i16) = (0, -1);
    let _t1: (u8, (i16, u32)) = (0, (-1, 1));
    let t: (u8, u16, i64, &amp;str, String) = (1u8, 2u16, 3i64, &quot;hello&quot;, String::from(&quot;, world&quot;));

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let t = (&quot;i&quot;, &quot;am&quot;, &quot;sunface&quot;);
    assert_eq!(t.2, &quot;sunface&quot;);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);
    println!(&quot;too long tuple: {:?}&quot;, too_long_tuple);
}
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let tup = (1, 6.4, &quot;hello&quot;);

    let (x, z, y) = tup;

    assert_eq!(x, 1);
    assert_eq!(y, &quot;hello&quot;);
    assert_eq!(z, 6.4);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let (x, y, z);

    (y, z, x) = (1, 2, 3);
    
    assert_eq!(x, 3);
    assert_eq!(y, 1);
    assert_eq!(z, 2);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="6">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let (x, y) = sum_multiply((2, 3));

    assert_eq!(x, 5);
    assert_eq!(y, 6);

    println!(&quot;Success!&quot;);
}

fn sum_multiply(nums: (i32, i32)) -&gt; (i32, i32) {
    (nums.0 + nums.1, nums.0 * nums.1)
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct"><a class="header" href="#struct">Struct</a></h1>
<h3 id="the-types-of-structs"><a class="header" href="#the-types-of-structs">The types of structs</a></h3>
<ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Person {
    name: String,
    age: u8,
    hobby: String
}
fn main() {
    let age = 23;
    let p = Person {
        name: String::from(&quot;Rehaan&quot;),
        age: age,
        hobby: String::from(&quot;sketching&quot;),
    };

    println!(&quot;Success!&quot;);
} 
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Unit;
trait SomeTrait {
    // ...Some behaviors defined here.
}

impl SomeTrait for Unit {  }
fn main() {
    let u = Unit;
    do_something_with_unit(u);

    println!(&quot;Success!&quot;);
} 

fn do_something_with_unit(u: Unit){ }  
// One could also use this 
// fn do_something_with_unit&lt;T&gt;(u: T) where T: SomeTrait{ }
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
fn main() {
    let v = Point(0, 127, 255);
    check_color(v);

    println!(&quot;Success!&quot;);
}   

fn check_color(p: Point) {
    let Point(x, _, _) = p;
    assert_eq!(x, 0);
    assert_eq!(p.1, 127);
    assert_eq!(p.2, 255);
 }
</code></pre></pre>
<h3 id="operating-on-structs"><a class="header" href="#operating-on-structs">Operating on structs</a></h3>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Person {
    name: String,
    age: u8,
}
fn main() {
    let age = 18;
    let mut p = Person {
        name: String::from(&quot;sunface&quot;),
        age,
    };
// sunface is definitely older than 18
    p.age = 30;

    p.name = String::from(&quot;sunfei&quot;);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Person {
    name: String,
    age: u8,
}
fn main() {
    println!(&quot;Success!&quot;);
} 

fn build_person(name: String, age: u8) -&gt; Person {
    Person {
        age,
        name 
    }
}
</code></pre></pre>
<ol start="6">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
fn main() {
    let u1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;sunface&quot;),
        active: true,
        sign_in_count: 1,
    };

    let u2 = set_email(u1);

    println!(&quot;Success!&quot;);
} 

fn set_email(u: User) -&gt; User {
    User {
        email: String::from(&quot;contact@im.dev&quot;),
        ..u
    }
}
</code></pre></pre>
<h3 id="print-the-structs"><a class="header" href="#print-the-structs">Print the structs</a></h3>
<ol start="7">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&amp;rect1); // Print debug info to stderr

    println!(&quot;{:#?}&quot;, rect1); // Print debug info to stdout
}
</code></pre></pre>
<h3 id="partial-move-1"><a class="header" href="#partial-move-1">Partial move</a></h3>
<h4 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h4>
<ol start="8">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct File {
    name: String,
    data: String,
}
fn main() {
    let f = File {
        name: String::from(&quot;readme.md&quot;),
        data: &quot;Rust By Practice&quot;.to_string()
    };

    let _name = f.name;

    println!(&quot;{}, {}&quot;, _name, f.data);
} 
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum"><a class="header" href="#enum">Enum</a></h1>
<ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Number {
    Zero,
    One,
    Two,
}

enum Number1 {
    Zero = 0,
    One,
    Two,
}

// Enum cannot be floats. They can however hold float values.
enum Number2 {
    Zero = 0,
    One = 1,
    Two = 2,
}


fn main() {
    assert_eq!(Number::One as isize, Number1::One as isize);
    assert_eq!(Number1::One as isize, Number2::One as isize);

    println!(&quot;Success!&quot;);
} 
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg1 = Message::Move{x: 1, y: 2}; // Instantiating with x = 1, y = 2 
    let msg2 = Message::Write(String::from(&quot;hello, world!&quot;)); // Instantiating with &quot;hello, world!&quot;

    println!(&quot;Success!&quot;);
} 
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::Move{x: 1, y: 1};

    if let Message::Move{x: a, y: b} = msg {
        assert_eq!(a, b);
    } else {
        panic!(&quot;WHY ARE YOU RUNNING! &quot;);
    }

    println!(&quot;Success!&quot;);
} 
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msgs: [Message; 3] = [
        Message::Quit,
        Message::Move{x:1, y:3},
        Message::ChangeColor(255,255,0)
    ];

    for msg in msgs {
        show_message(msg)
    }
} 

fn show_message(msg: Message) {
    println!(&quot;{:#?}&quot;, msg);
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let five = Some(5);
    let six = plus_one(five);
    let _none = plus_one(None);

    if let Some(n) = six {
        println!(&quot;{}&quot;, n);
        println!(&quot;Success!&quot;);
        return
    } 
        
    panic!(&quot;WHY ARE YOU RUNNINGÔºÅ&quot;);
} 

fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}
</code></pre></pre>
<ol start="6">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use crate::List::*;

enum List {
    Cons(u32, Box&lt;List&gt;),
    Nil,
}

impl List {
    fn new() -&gt; List {
        List::Nil
    }

    fn prepend(self, elem: u32) -&gt; Self {
        Cons(elem, Box::new(self))
    }

    fn len(&amp;self) -&gt; u32 {
        match *self {
            Cons(_, ref tail) =&gt; 1 + tail.len(), // recurssion
            Nil =&gt; 0
        }
    }

    fn stringify(&amp;self) -&gt; String {
        match *self {
            Cons(head, ref tail) =&gt; {
                format!(&quot;{}, {}&quot;, head, tail.len())
            },
            Nil =&gt; {
                format!(&quot;Nil&quot;)
            },
        }
    }
}

fn main() {
    let mut list = List::new();

    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    println!(&quot;linked list has length: {}&quot;, list.len());
    println!(&quot;{}&quot;, list.stringify());
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flow-control"><a class="header" href="#flow-control">Flow control</a></h1>
<h3 id="ifelse"><a class="header" href="#ifelse">If/else</a></h3>
<ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let n = 5;

    if n &lt; 0 {
        println!(&quot;{} is negative&quot;, n);
    } else if n &gt; 0 {
        println!(&quot;{} is positive&quot;, n);
    } else {
        println!(&quot;{} is zero&quot;, n);
    }
} 
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let n = 5;

    let big_n =
        if n &lt; 10 &amp;&amp; n &gt; -10 {
            println!(&quot;, and is a small number, increase ten-fold&quot;);
            10 * n
        } else {
            println!(&quot;, and is a big number, halve the number&quot;);
            n / 2
        };

    println!(&quot;{} -&gt; {}&quot;, n, big_n);
} 
</code></pre></pre>
<h3 id="for"><a class="header" href="#for">For</a></h3>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    for n in 1..100 {
        if n == 100 {
            panic!(&quot;NEVER LET THIS RUN &quot;)
        }
    }

    println!(&quot;Success!&quot;);
} 
</code></pre></pre>
<ol start="4">
<li>üåüüåü </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let names = [String::from(&quot;liming&quot;),String::from(&quot;hanmeimei&quot;)];
    for name in &amp;names {
        println!(&quot;{} is cool&quot;, name);
    }

    println!(&quot;{:?}&quot;, names);

    let numbers = [1, 2, 3];
    for n in numbers {
        println!(&quot;{}&quot;, n); 
    }
    
    println!(&quot;{:?}&quot;, numbers);
} 
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let a = [4, 3, 2, 1];

    for (i,v) in a.iter().enumerate() {
        println!(&quot;The {}th element is {}&quot;,i+1,v);
    }
}
</code></pre></pre>
<h3 id="while"><a class="header" href="#while">While</a></h3>
<ol start="6">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut n = 1;

    while n &lt;= 30 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }


        n += 1;
    }

    println!(&quot;n reached {}, so loop is over&quot;,n);
}
</code></pre></pre>
<h3 id="continue-and-break"><a class="header" href="#continue-and-break">Continue and break</a></h3>
<ol start="7">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut n = 0;
    for i in 0..=100 {
       if n == 66 {
           break; 
       }
       n += 1;
    }

    assert_eq!(n, 66);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="8">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut n = 0;
    for i in 0..=100 {
       if n != 66 {
           n+=1;
           continue;
       }
       
       break;
    }

    assert_eq!(n, 66);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="loop"><a class="header" href="#loop">Loop</a></h3>
<ol start="9">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut count = 0u32;

    println!(&quot;Let's count until infinity!&quot;);

    loop {
        count += 1;

        if count == 3 {
            println!(&quot;three&quot;);
            continue;
        }

        println!(&quot;{}&quot;, count);

        if count == 5 {
            println!(&quot;OK, that's enough&quot;);

            break;
        }
    }

    assert_eq!(count, 5);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="10">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    assert_eq!(result, 20);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="11">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut count = 0;
    'outer: loop {
        'inner1: loop {
            if count &gt;= 20 {
                break 'inner1; 
            }
            count += 2;
        }

        count += 5;

        'inner2: loop {
            if count &gt;= 30 {
                break 'outer;
            }

            continue 'outer;
        }
    }

    assert!(count == 30);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-match"><a class="header" href="#pattern-match">Pattern Match</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch18-00-patterns.html">Rust Book 18</a></li>
<li>ÁÆÄ‰Ωì‰∏≠Êñá: <a href="https://course.rs/basic/match-pattern/intro.html">RustËØ≠Ë®ÄÂú£Áªè - Ê®°ÂºèÂåπÈÖç</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-if-let"><a class="header" href="#match-if-let">Match, if let</a></h1>
<h3 id="match"><a class="header" href="#match">Match</a></h3>
<ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East =&gt; println!(&quot;East&quot;),
        Direction::South | Direction::North  =&gt; {
            println!(&quot;South or North&quot;);
        },
        _ =&gt; println!(&quot;YOU SHALL NOT BE HERE!&quot;),
    };
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let boolean = true;

    let binary = match boolean {
        true =&gt; 1,
        false =&gt; 0,
    };

    assert_eq!(binary, 1);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msgs = [
        Message::Quit,
        Message::Move{x:1, y:3},
        Message::ChangeColor(255,255,0)
    ];

    for msg in msgs {
        show_message(msg)
    }

    println!(&quot;Success!&quot;);
} 

fn show_message(msg: Message) {
    match msg {
        Message::Move{x: a, y: b} =&gt; {
            assert_eq!(a, 1);
            assert_eq!(b, 3);
        },
        Message::ChangeColor(_, g, b) =&gt; {
            assert_eq!(g, 255);
            assert_eq!(b, 0);
        }
        _ =&gt; println!(&quot;no data in these variants&quot;)
    }
}
</code></pre></pre>
<h3 id="matches"><a class="header" href="#matches">matches!</a></h3>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let alphabets = ['a', 'E', 'Z', '0', 'x', '9' , 'Y'];

    for ab in alphabets {
        assert!(matches!(ab, 'a'..='z' | 'A'..='Z' | '0'..='9')); 
        // checking with regular expression?
        // &quot;matches&quot; macro is new to me. Very interesting though.
        // I can already imagine it being used for validating stuff.
    }

    println!(&quot;Success!&quot;);
} 
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum MyEnum {
    Foo,
    Bar
}

fn main() {
    let mut count = 0;

    let v = vec![MyEnum::Foo,MyEnum::Bar,MyEnum::Foo];
    for e in v {
        if matches!(e, MyEnum::Foo) {
            // &quot;matches&quot; macro seems quite handy.
            // NOICE
            count += 1;
        }
    }

    assert_eq!(count, 2);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<h3 id="if-let"><a class="header" href="#if-let">If let</a></h3>
<ol start="6">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let o = Some(7);

    if let Some(i) = o {
        println!(&quot;This is a really long string and `{:?}`&quot;, i);
        println!(&quot;Success!&quot;);
    };
}
</code></pre></pre>
<ol start="7">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Foo {
    Bar(u8)
}

fn main() {
    let a = Foo::Bar(1);

    if let Foo::Bar(i) = a {
        println!(&quot;foobar holds the value: {}&quot;, i);
        println!(&quot;Success!&quot;);
    }
}
</code></pre></pre>
<ol start="8">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Foo {
    Bar,
    Baz,
    Qux(u32)
}

fn main() {
    let a = Foo::Qux(10);

    match a {
       Foo::Bar =&gt;  println!(&quot;match foo::bar&quot;),
       Foo::Baz =&gt;  println!(&quot;match foo::baz&quot;),
       _ =&gt; println!(&quot;match others&quot;),
    }
}
</code></pre></pre>
<h3 id="shadowing-1"><a class="header" href="#shadowing-1">Shadowing</a></h3>
<ol start="9">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let age = Some(30);
    if let Some(age) = age {
       assert_eq!(age, 30);
    }
    
    match age {
        Some(age) =&gt;  println!(&quot;age is a new variable, it's value is {}&quot;,age),
        _ =&gt; ()
    }
 }
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patterns"><a class="header" href="#patterns">Patterns</a></h1>
<ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>fn match_number(n: i32) {
    match n {
	1 =&gt; println!(&quot;One!&quot;),
	
	2 | 3 | 4 | 5 =&gt; println!(&quot;match 2 -&gt; 5&quot;),
	
	6..=10 =&gt; println!(&quot;match 6 -&gt; 10&quot;),

	_ =&gt; println!(&quot;match 11 -&gt; +infinite&quot;)
    }
}
<span class="boring">match_number(4);
</span><span class="boring">} 
</span></code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 5, y: 10 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        Point { x: 0..=5, y: y@ (10 | 20 | 30) } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Message {
    Hello { id: i32 },
}

fn main() {
    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id:  id@3..=7,
        } =&gt; println!(&quot;Found an id in range [3, 7]: {}&quot;, id),
        Message::Hello { id: newid@(10 | 11 | 12) } =&gt; {
            println!(&quot;Found an id in another range [10, 12]: {}&quot;, newid)
        }
        Message::Hello { id } =&gt; println!(&quot;Found some other id: {}&quot;, id),
    }
}
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let num = Some(4);
    let split = 5;
    match num {
        Some(x) if x != 0 =&gt; assert!(x &lt; split),
        Some(x) =&gt; assert!(x &gt;= split),
        None =&gt; (),
    }

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let numbers = (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048);

    match numbers {
        (first,..,last) =&gt; {
           assert_eq!(first, 2);
           assert_eq!(last, 2048);
        }
    }

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="6">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut v = String::from(&quot;hello,&quot;);
    let r = &amp;mut v;

    match r {
        value =&gt; value.push_str(&quot; world!&quot;), // r is already a mutable borrow
    }

	// why can't we just do 
	// r.push_str(&quot; world!&quot;) üòÜ
	println!(&quot;{}&quot;, v);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="second-assignment"><a class="header" href="#second-assignment">Second assignment</a></h1>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 { 
    	self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    assert_eq!(rect1.area(), 1500);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct TrafficLight {
    color: String,
}

impl TrafficLight {
    pub fn show_state(&amp;self)  {
        println!(&quot;the current state is {}&quot;, self.color);
    }
}
fn main() {
    let light = TrafficLight{
        color: &quot;red&quot;.to_owned(),
    };
    light.show_state();
    println!(&quot;{:?}&quot;, light);
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct TrafficLight {
    color: String,
}

impl TrafficLight {
    pub fn show_state(Self)  {
        println!(&quot;the current state is {}&quot;, self.color);
    }

    pub fn change_state(&amp;mut self) {
        self.color = &quot;green&quot;.to_string()
    }
}
fn main() {
    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct TrafficLight {
    color: String,
}

impl TrafficLight {
    pub fn new() -&gt; Self {
    	TrafficLight {
        	color: &quot;red&quot;.to_owned(),
        }
    }

    pub fn get_state(&amp;self) -&gt; &amp;str {
        &amp;self.color
    }
}

fn main() {
    let light = TrafficLight::new();
    assert_eq!(light.get_state(), &quot;red&quot;);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}


fn main() {
    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="6">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
#[derive(Debug)]
enum TrafficLightColor {
    Red,
    Yellow,
    Green,
}

impl TrafficLightColor {
	pub fn color(&amp;self) -&gt; &amp;str {
		match *self {
			TrafficLightColor::Red =&gt; &quot;red&quot;,
			TrafficLightColor::Yellow =&gt; &quot;yellow&quot;,
			TrafficLightColor::Green =&gt; &quot;green&quot;,
		}
	}	    
}

fn main() {
    let c = TrafficLightColor::Yellow;

    assert_eq!(c.color(), &quot;yellow&quot;);

    println!(&quot;{:?}&quot;,c);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-and-traits"><a class="header" href="#generics-and-traits">Generics and Traits</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch10-00-generics.html">Rust Book 10.1, 10.2</a></li>
<li>ÁÆÄ‰Ωì‰∏≠Êñá: <a href="https://course.rs/basic/trait/intro.html">RustËØ≠Ë®ÄÂú£Áªè - Ê®°ÂºèÂåπÈÖç</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn reg_fn(_s: S) {}

fn gen_spec_t(_s: SGen&lt;A&gt;) {}

fn gen_spec_i32(_s: SGen&lt;i32&gt;) {}

fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) {}

fn main() {
    reg_fn(S(A)); 
    gen_spec_t(SGen(A)); 
    gen_spec_i32(SGen(12));

    generic::&lt;char&gt;(SGen('r'));

    generic(SGen('r'));

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn sum&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(x: T, y: T) -&gt; T {
	x + y	
}

fn sub&lt;T: std::ops::Sub&lt;Output = T&gt;&gt;(x: T, y: T) -&gt; T {
	x - y	
}

fn opt&lt;T: std::ops::Add&lt;Output = T&gt;,
       E: std::ops::Sub&lt;Output = E&gt;,
       FT: Fn(T, T) -&gt; T,
       FE: Fn(T, E) -&gt; E&gt;
       (x: T, y: A, T: E, func1: FT, func2: FE)  -&gt; E {
       (func1)((func2)(x, y), z)
}

fn calc&lt;E: std::ops::Add&lt;Output = E&gt;, F&gt;
	(x: E, y: E, func: F) -&gt; D
	where F: Fn(E, E)     -&gt; E {
	(func)(x, y)
}

fn main() {
    assert_eq!(5, sum(2i8, 3i8));
    assert_eq!(50, sum(20, 30));
    assert_eq!(2.46, sum(1.23, 1.23));

    assert_eq!(5, calc(2_i8, 3_i8, sum));
    assert_eq!(-20, calc(20, 30, sub));
    
    assert_eq!(-5, opt(2_i8, 3_i8, 10, sum, sub));

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Point&lt;T&gt; {
	x: T,
	y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Point&lt;T, E&gt; {
    x: T,
    y: E,
}

fn main() {
    let p = Point{x: 5, y : &quot;hello&quot;.to_string()};

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Val&lt;T&gt; {
    val: T,
}

impl &lt;T&gt;Val &lt;T&gt;{
    fn value(&amp;self) -&gt; &amp;T {
        &amp;self.val
    }
}


fn main() {
    let x = Val{ val: 3.0 };
    let y = Val{ val: &quot;hello&quot;.to_string()};
    println!(&quot;{}, {}&quot;, x.value(), y.value());
}
</code></pre></pre>
<ol start="6">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;R, S&gt;(self, p: Point&lt;R, S&gt;) -&gt; Point&lt;T, S&gt; {
    	x: self.x,
	y: p.y	
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10 };
    let p2 = Point { x: &quot;Hello&quot;, y: '‰∏≠'};

    let p3 = p1.mixup(p2);

    assert_eq!(p3.x, 5);
    assert_eq!(p3.y, '‰∏≠');

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="7">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl Point &lt;f32&gt; { // You can specify different implimentations for different types.
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

fn main() {
    let p = Point{x: 5_f32, y: 10_f32};
    println!(&quot;{}&quot;,p.distance_from_origin());
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Array&lt;T, const N: usize&gt; {
    data : [T; N]
}

fn main() {
    let arrays = [
        Array{
            data: [1, 2, 3],
        },
        Array {
            data: [1, 2, 3], // They all should be the same type or else too ambigious.
        },
        Array {
            data: [1, 2]
        }
    ];

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn print_array&lt;T: std::fmt::Debug, const N: usize&gt;(arr: &amp;[T; N]) {
    println!(&quot;{:?}&quot;, *arr);
}
fn main() {
    let arr = [1, 2, 3];
    print_array(&amp;arr);

    let arr = [&quot;hello&quot;, &quot;world&quot;];
    print_array(&amp;arr);
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#![allow(incomplete_features)]
#![feature(generic_const_exprs)]

fn check_size&lt;T&gt;(val: T)
where
    Assert&lt;{ core::mem::size_of::&lt;T&gt;() &lt; 768 }&gt;: IsTrue,
{
    //...
}

fn main() {
    check_size([0u8; 767]); 
    check_size([0i32; 191]);
    check_size([&quot;hello‰Ω†Â•Ω&quot;; 47]);
    check_size([(); 31].map(|_| &quot;hello‰Ω†Â•Ω&quot;.to_string())); 
    check_size(['‰∏≠'; 191]); 

    println!(&quot;Success!&quot;);
}



pub enum Assert&lt;const CHECK: bool&gt; {}

pub trait IsTrue {}

impl IsTrue for Assert&lt;true&gt; {}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Hello {
    fn say_hi(&amp;self) -&gt; String {
        String::from(&quot;hi&quot;)
    }

    fn say_something(&amp;self) -&gt; String;
}

struct Student {}
impl Hello for Student {
	fn say_something(&amp;self) -&gt; String {
		&quot;I'm a good student&quot;.to_owned()
	}
}

struct Teacher {}
impl Hello for Teacher {
    fn say_hi(&amp;self) -&gt; String {
        String::from(&quot;Hi, I'm your new teacher&quot;)
    }

    fn say_something(&amp;self) -&gt; String {
        String::from(&quot;I'm not a bad teacher&quot;) // Only a bad teacher would say that... sus...
    }

}

fn main() {
    let s = Student {};
    assert_eq!(s.say_hi(), &quot;hi&quot;);
    assert_eq!(s.say_something(), &quot;I'm a good student&quot;);

    let t = Teacher {};
    assert_eq!(t.say_hi(), &quot;Hi, I'm your new teacher&quot;);
    assert_eq!(t.say_something(), &quot;I'm not a bad teacher&quot;);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<p>&quot;PartialEq&quot; for numerical comparisions. &quot;PartialOrd&quot; for binary comparisions. &quot;Debug&quot; to print the struct. One &quot;derive&quot; to rule them all.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
#[derive(PartialEq, PartialOrd)]
struct Centimeters(f64);

#[derive(Debug)]
struct Inches(i32);

impl Inches {
    fn to_centimeters(&amp;self) -&gt; Centimeters {
        let &amp;Inches(inches) = self;
        Centimeters(inches as f64 * 2.54)
    }
}

#[derive(PartialEq, PartialOrd, Debug)]
struct Seconds(i32);

fn main() {
    let _one_second = Seconds(1);

    println!(&quot;One second looks like: {:?}&quot;, _one_second);
    let _this_is_true = (_one_second == _one_second);
    let _this_is_true = (_one_second &gt; _one_second);

    let foot = Inches(12);

    println!(&quot;One foot equals {:?}&quot;, foot);

    let meter = Centimeters(100.0);

    let cmp =
        if foot.to_centimeters() &lt; meter {
            &quot;smaller&quot;
        } else {
            &quot;bigger&quot;
        };

    println!(&quot;One foot is {} than one meter.&quot;, cmp);
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::ops;

fn multiply&lt;T: ops::Mul&lt;Output = T&gt;&gt;(x: T, y: T) -&gt; T {
	x * y
} 

fn main() {
    assert_eq!(6, multiply(2u8, 3u8));
    assert_eq!(5.0, multiply(1.0, 5.0));

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::ops;

struct Foo;
struct Bar;

// Huh? ... You need Debug trait to assert non-scalar types.
// You learn something new everyday.
#[derive(partialEq, Debug)]
struct FooBar;

#[derive(PArtialEq, Debug)]
struct BarFoo;

impl ops::Add&lt;Bar&gt; for Foo {
    type Output = FooBar;

    fn add(self, _rhs: Bar) -&gt; FooBar {
        FooBar
    }
}

impl ops::Sub&lt;Bar&gt; for Foo {
    type Output = BarFoo;

    fn sub(self, _rhs: Bar) -&gt; BarFoo {
        BarFoo
    }
}

fn main() {
    assert_eq!(Foo + Bar, FooBar);
    assert_eq!(Foo - Bar, BarFoo);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
trait Summary {
    fn summarize(&amp;self) -&gt; String;
}

#[derive(Debug)]
struct Post {
    title: String,
    author: String,
    content: String,
}

impl Summary for Post {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;The author of post {} is {}&quot;, self.title, self.author)
    }
}

#[derive(Debug)]
struct Weibo {
    username: String,
    content: String,
}

impl Summary for Weibo {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{} published a weibo {}&quot;, self.username, self.content)
    }
}

fn main() {
    let post = Post {
        title: &quot;Popular Rust&quot;.to_string(),
        author: &quot;Sunface&quot;.to_string(),
        content: &quot;Rust is awesome!&quot;.to_string(),
    };
    let weibo = Weibo {
        username: &quot;sunface&quot;.to_string(),
        content: &quot;Weibo seems to be worse than Tweet&quot;.to_string(),
    };

    summary(post);
    summary(weibo);

    println!(&quot;{:?}&quot;, post);
    println!(&quot;{:?}&quot;, weibo);
}

fn summary(obj: &amp;impl Summary) -&gt; &amp;str {	
	obj.summarize()
}

</code></pre></pre>
<ol start="6">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Sheep {}
struct Cow {}

trait Animal {
    fn noise(&amp;self) -&gt; String;
}

impl Animal for Sheep {
    fn noise(&amp;self) -&gt; String {
        &quot;baaaaah!&quot;.to_string()
    }
}

impl Animal for Cow {
    fn noise(&amp;self) -&gt; String {
        &quot;moooooo!&quot;.to_string()
    }
}

fn random_animal(random_number: f64) -&gt; Box&lt;dyn Animal&gt; {
    if random_number &lt; 0.5 {
        Box::new(Sheep {})
    } else {
        Box::new(Cow {})
    }
}

fn main() {
    let random_number = 0.234;
    let animal = random_animal(random_number);
    println!(&quot;You've randomly chosen an animal, and it says {}&quot;, animal.noise());
}
</code></pre></pre>
<ol start="7">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    assert_eq!(sum(1, 2), 3);
}

fn sum&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(x: T, y: T) -&gt; T {
    x + y
}
</code></pre></pre>
<ol start="8">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
    }
}

impl&lt;T: std::fmt::Debug + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {:?}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {:?}&quot;, self.y);
        }
}
}

#[derive(Debug, PartialEq, PartialEq)]
struct Unit(i32);

fn main() {
    let pair = Pair{
        x: Unit(1),
        y: Unit(3)
    };

    pair.cmp_display();
}
</code></pre></pre>
<ol start="9">
<li></li>
</ol>
<p>Fn traits can not only store closures but, also functions. Not to be confused with &quot;fn&quot; which is a type. Also, &quot;fn&quot; can only hold functions.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn example1() {
    struct Cacher&lt;T: Fn(u32) -&gt; u32&gt; {
        calculation: T,
        value: Option&lt;u32&gt;,
    }

    impl&lt;T: Fn(u32) -&gt; u32&gt; Cacher&lt;T&gt; {
        fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
            Cacher {
                calculation,
                value: None,
            }
        }

        fn value(&amp;mut self, arg: u32) -&gt; u32 {
            match self.value {
                Some(v) =&gt; v,
                None =&gt; {
                    let v = (self.calculation)(arg);
                    self.value = Some(v);
                    v
                },
            }
        }
    }

    let mut cacher = Cacher::new(|x| x+1);
    assert_eq!(cacher.value(10), 11);
    assert_eq!(cacher.value(15), 11);
}


fn example2() {
    struct Cacher&lt;T&gt;
        where T: Fn(u32) -&gt; u32,
    {
        calculation: T,
        value: Option&lt;u32&gt;,
    }

    impl&lt;T&gt; Cacher&lt;T&gt;
        where T: Fn(u32) -&gt; u32,
    {
        fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
            Cacher {
                calculation,
                value: None,
            }
        }

        fn value(&amp;mut self, arg: u32) -&gt; u32 {
            match self.value {
                Some(v) =&gt; v,
                None =&gt; {
                    let v = (self.calculation)(arg);
                    self.value = Some(v);
                    v
                },
            }
        }
    }

    let mut cacher = Cacher::new(|x| x+1);
    assert_eq!(cacher.value(20), 21);
    assert_eq!(cacher.value(25), 26);
}



fn main() {
    example1();
    example2();

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
trait Bird {
    fn quack(&amp;self) -&gt; String;
}

struct Duck;
impl Duck {
    fn swim(&amp;self) {
        println!(&quot;Look, the duck is swimming&quot;)
    }
}
struct Swan;
impl Swan {
    fn fly(&amp;self) {
        println!(&quot;Look, the duck.. oh sorry, the swan is flying&quot;)
    }
}

impl Bird for Duck {
    fn quack(&amp;self) -&gt; String{
        &quot;duck duck&quot;.to_string()
    }
}

impl Bird for Swan {
    fn quack(&amp;self) -&gt; String{
        &quot;swan swan&quot;.to_string()
    }
}

fn main() {
    let duck = Duck;
    duck.swim();

    if let Some(bird) = hatch_a_bird(2) {
        assert_eq!(bird.quack(), &quot;duck duck&quot;);
    }

    if let Some(bird) = hatch_a_bird(1) {
        assert_eq!(bird.quack(), &quot;swan swan&quot;);
    }

    println!(&quot;Success!&quot;);
}   

fn hatch_a_bird(bird_option: u32) -&gt; Option&lt;Box&lt;dyn Bird&gt;&gt; {
	match bird_option {
		1 =&gt; Some(Box::new(Swan)),
		2 =&gt; Some(Box::new(Duck)),
		_ =&gt; None,
	}
}

// There! this code is much safer now. Kinda defeats the point of assert now that I think about it.
// Nevermind. Let's carry on. 
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Bird {
    fn quack(&amp;self);
}

struct Duck;
impl Duck {
    fn fly(&amp;self) {
        println!(&quot;Look, the duck is flying&quot;)
    }
}
struct Swan;
impl Swan {
    fn fly(&amp;self) {
        println!(&quot;Look, the duck.. oh sorry, the swan is flying&quot;)
    }
}

impl Bird for Duck {
    fn quack(&amp;self) {
        println!(&quot;{}&quot;, &quot;duck duck&quot;);
    }
}

impl Bird for Swan {
    fn quack(&amp;self) {
        println!(&quot;{}&quot;, &quot;swan swan&quot;);
    }
}

fn main() {
    let birds: [Box&lt;dyn Bird&gt;; 3] = [Box::new(Duck), Box::new(Swan), Box::new(Duck)];

    for bird in birds {
        bird.quack();
    }
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Draw {
    fn draw(&amp;self) -&gt; String;
}

impl Draw for u8 {
    fn draw(&amp;self) -&gt; String {
        format!(&quot;u8: {}&quot;, *self)
    }
}

impl Draw for f64 {
    fn draw(&amp;self) -&gt; String {
        format!(&quot;f64: {}&quot;, *self)
    }
}

fn main() {
    let x = 1.1f64;
    let y = 8u8;

    draw_with_box(Box::new(x));

    draw_with_ref(&amp;y);

    println!(&quot;Success!&quot;);
}

fn draw_with_box(x: Box&lt;dyn Draw&gt;) {
    x.draw();
}

fn draw_with_ref(x: &amp;u8) {
    x.draw();
}
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
trait Foo {
    fn method(&amp;self) -&gt; String;
}

impl Foo for u8 {
    fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) }
}

impl Foo for String {
    fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) }
}

fn static_dispatch&lt;T: Foo&gt;(x: T) {x.method();}

fn dynamic_dispatch(x: &amp;dyn Foo) {x.method();}

fn main() {
    let x = 5u8;
    let y = &quot;Hello&quot;.to_string();

    static_dispatch(x);
    dynamic_dispatch(&amp;y);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
trait MyTrait {
    fn f(&amp;self) -&gt; Self;
}

impl MyTrait for u32 {
    fn f(&amp;self) -&gt; u32 { 42 }
}

impl MyTrait for String {
    fn f(&amp;self) -&gt; String { self.clone() }
}

fn my_function(x: impl MyTrait) -&gt; impl MyTrait {
    x.f()
}

fn main() {
    my_function(Box::new(13_u32));
    my_function(Box::new(String::from(&quot;abc&quot;)));

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Pilot {
    fn fly(&amp;self) -&gt; String;
}

trait Wizard {
    fn fly(&amp;self) -&gt; String;
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) -&gt; String {
        String::from(&quot;This is your captain speaking.&quot;)
    }
}

impl Wizard for Human {
    fn fly(&amp;self) -&gt; String {
        String::from(&quot;Up!&quot;)
    }
}

impl Human {
    fn fly(&amp;self) -&gt; String {
        String::from(&quot;*waving arms furiously*&quot;)
    }
}

fn main() {
    let person = Human;
    
    Pilot::fly(&amp;person);
    assert_eq!(person.fly, &quot;This is your captain speaking.&quot;);
    Wizard::fly(&amp;person);
    assert_eq!(person.fly, &quot;Up!&quot;);
    Human::fly(&amp;person);
    assert_eq!(person.fly, &quot;*waving arms furiously*&quot;);

    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
trait Person {
    fn name(&amp;self) -&gt; String;
}

trait Student: Person {
    fn university(&amp;self) -&gt; String;
}

trait Programmer {
    fn fav_language(&amp;self) -&gt; String;
}

trait CompSciStudent: Programmer + Student {
    fn git_username(&amp;self) -&gt; String;
}

fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String {
    format!(
        &quot;My name is {} and I attend {}. My favorite language is {}. My Git username is {}&quot;,
        student.name(),
        student.university(),
        student.fav_language(),
        student.git_username()
    )
}

struct CSStudent {
    name: String,
    university: String,
    fav_language: String,
    git_username: String
}

impl Person for CSStudent {
	fn name(&amp;self) -&gt; String {
		self.name.clone()
	}	
}

impl Student for CSStudent {
	fn university(&amp;self) -&gt; String {
		self.university.clone()
	}
}

impl Programmer for CSStudent {
	fn fav_language(&amp;self) -&gt; String {
		self.fav_language.clone()
	}
}

impl CompSciStudent CSStudent {
	fn git_username(&amp;self) -&gt; String {
		self.git_username.clone()
	}
}

fn main() {
    let student = CSStudent {
        name: &quot;Sunfei&quot;.to_string(),
        university: &quot;XXX&quot;.to_string(),
        fav_language: &quot;Rust&quot;.to_string(),
        git_username: &quot;sunface&quot;.to_string()
    };

    println!(&quot;{}&quot;, comp_sci_student_greeting(__));
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt;

// DEFINE a newtype `Pretty` here
struct Pretty(String)

impl fmt::Display for Pretty {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;\&quot;{}\&quot;&quot;, self.0.clone() + &quot;, world&quot;)
    }
}

fn main() {
    let w = Pretty(&quot;hello&quot;.to_string());
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collection-types"><a class="header" href="#collection-types">Collection Types</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch08-00-common-collections.html">Rust Book Chapter 8</a></li>
<li>ÁÆÄ‰Ωì‰∏≠Êñá: <a href="https://course.rs/basic/collections/intro.html">RustËØ≠Ë®ÄÂú£Áªè - ÈõÜÂêàÁ±ªÂûã</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="basic-operations"><a class="header" href="#basic-operations">Basic operations</a></h3>
<ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let mut s: String = String::from(&quot;hello, &quot;);
    s.push_str(&quot;world&quot;);
    s.push('!');

    move_ownership(s.clone()); // ownership not moved instead cloned.

    assert_eq!(s, &quot;hello, world!&quot;);

    println!(&quot;Success!&quot;)
}

fn move_ownership(s: String) {
    println!(&quot;ownership of \&quot;{}\&quot; is moved here!&quot;, s)
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {  
   let mut s = String::from(&quot;hello, world&quot;);

   let slice1: &amp;str = &amp;s[..];
// let slice1: &amp;str = s.as_str();
   assert_eq!(slice1, &quot;hello, world&quot;);

   let slice2 = &amp;s[0..5];
   assert_eq!(slice2, &quot;hello&quot;);

   let mut slice3: String = s; 
   slice3.push('!');
   assert_eq!(slice3, &quot;hello, world!&quot;);

   println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<p>Two Heap allocations have happned here. &quot;s&quot; is one then another is created for after using &quot;slice&quot; to create one.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021"> fn main() {  
   let s: String = String::from(&quot;hello, world!&quot;);

   let slice: &amp;str = &amp;s;

   let s: String = slice.to_string();

   assert_eq!(s, &quot;hello, world!&quot;);

   println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = String::from(&quot;hello, ‰∏ñÁïå&quot;);
    let slice1 = s[0..1];
    assert_eq!(slice1, &quot;h&quot;);

    let slice2 = &amp;s[7..10];
    assert_eq!(slice2, &quot;‰∏ñ&quot;);
    
    for (i, c) in s.chars().enumerate() {
        if i == 7 {
            assert_eq!(c, '‰∏ñ')
        }
    }

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let mut s = String::new();
    s.push_str();

    let v = vec![104, 101, 108, 108, 111];

    let s1 = String::from_uft8(v).unwrap(); 
// Cause string is essentially a wrapper for vector of u8 numbers.
    
    assert_eq!(s, s1);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="6">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s = String::with_capacity(25);

    println!(&quot;{}&quot;, s.capacity());

    for _ in 0..2 {
        s.push_str(&quot;hello&quot;);
        println!(&quot;{}&quot;, s.capacity());
    }

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<p>Essentially structure of a string from source</p>
<pre><code>
struct String {
	vec: Vec&lt;u8&gt;
}

impl String {
	fn with_capacity(capacity: usize) -&gt; String {
		String {vec: Vec::with_capacity(capacity)}
	}
}
</code></pre>
<h2 id="from-the-std-crate"><a class="header" href="#from-the-std-crate">From the std crate</a></h2>
<p>The capacity of a vector is the amount of space allocated for any future
elements that will be added onto the vector. This is not to be confused with
the <em>length</em> of a vector, which specifies the number of actual elements
within the vector. If a vector's length exceeds its capacity, its capacity
will automatically be increased, but its elements will have to be
reallocated.</p>
<p>For example, a vector with capacity 10 and length 0 would be an empty vector
with space for 10 more elements. Pushing 10 or fewer elements onto the
vector will not change its capacity or cause reallocation to occur. However,
if the vector's length is increased to 11, it will have to reallocate, which
can be slow. For this reason, it is recommended to use [<code>Vec::with_capacity</code>]
whenever possible to specify how big the vector is expected to get.</p>
<p>Essentially a string with capacity is just capacity is the reserved space that
a string expects to get so it allocates it just in case and increases when 
more space is demanded. Makes sense. Also, I can use &quot;with_capacity&quot; now to reduce
useless memory allocation. Yay, to more efficient code!</p>
<ol start="7">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::mem;

fn main() {
    let story = String::from(&quot;Rust By Practice&quot;);

    let mut story = mem::ManuallyDrop::new(story);

    let ptr = story.as_mut_ptr(); // mutable pointer like in C/C++.
    let len = story.len();
    let capacity = story.capacity();

    assert_eq!(16, len);

    let s = unsafe { String::from_raw_parts(ptr, len, capacity) }; // lo here come the dreaded unsafe block

    assert_eq!(*story, s);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let arr: [u8; 3] = [1, 2, 3];
    
    let v = Vec::from(arr);
    is_vec(&amp;v);

    let v = vec![1, 2, 3];
    is_vec(&amp;v);

    let v = vec!(1, 2, 3);
    is_vec(&amp;v);
    
    let mut v1 = Vec::new();
    for i in &amp;arr {
	v1.push(*i);
    }
    is_vec(&amp;v1);
 
    assert_eq!(v, *v1);

    println!(&quot;Success!&quot;)
}

fn is_vec(v: &amp;Vec&lt;u8&gt;) {}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let mut v1 = Vec::from([1, 2, 4]);
    v1.pop();
    v1.push(3);
    
    let mut v2 = Vec::new();
    v2.extend([1, 2, 3]);

    assert_eq!(v1, v2);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let arr = [1, 2, 3];
    let v1 = Vec::from(arr);
    let v2: Vec&lt;i32&gt; = arr.into();
 
    assert_eq!(v1, v2);
    
    let s = &quot;hello&quot;.to_string();
    let v1: Vec&lt;u8&gt; = s.into();

    let s = &quot;hello&quot;.to_string();
    let v2 = s.into_bytes();
    assert_eq!(v1, v2);

    let s = &quot;hello&quot;;
    let v3 = Vec::from(s);
    assert_eq!(v2, v3);

    let v4: Vec&lt;i32&gt; = [0; 10].into_iter().collect();
    assert_eq!(v4, vec![0; 10]);

    println!(&quot;Success!&quot;)
 }
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let mut v = Vec::from([1, 2, 3]);
    for i in 0..5 {
        println!(&quot;{:?}&quot;, v.get(i))
    }

    for i in 0..5 {
	if let Some(x) = v.get(i) {
		v[i] = x + 1
	} else {
		v.push(i + 2)
	}
    }
    
    assert_eq!(v, vec![2, 3, 4, 5, 6]);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let mut v = vec![1, 2, 3];

    let slice1 = &amp;v[..];
    let slice2 = &amp;v[0..3];
    
    assert_eq!(slice1, slice2);
    
    let vec_ref: &amp;mut Vec&lt;i32&gt; = &amp;mut v;
    (*vec_ref).push(4);
    let slice3 = &amp;mut v[0..];

    assert_eq!(slice3, &amp;[1, 2, 3, 4]);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="6">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut vec = Vec::with_capacity(10);

    assert_eq!(vec.len(), 0);
    assert_eq!(vec.capacity(), 10);

    for i in 0..10 {
        vec.push(i);
    }
    assert_eq!(vec.len(), 10);
    assert_eq!(vec.capacity(), 10);

    vec.push(11);
    assert_eq!(vec.len(), 11);
    assert!(vec.capacity() &gt;= 11);


    let mut vec = Vec::with_capacity(100);
    for i in 0..100 {
        vec.push(i);
    }

    assert_eq!(vec.len(), 100);
    assert_eq!(vec.capacity(), 100);
    
    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="7">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug, PartialEq)]
enum IpAddr {
    V4(String),
    V6(String),
}
fn main() {
    let v : Vec&lt;IpAddr&gt; = vec![
	

    ]; 
    
    assert_eq!(v[0], IpAddr::V4(&quot;127.0.0.1&quot;.to_string()));
    assert_eq!(v[1], IpAddr::V6(&quot;::1&quot;.to_string()));

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="8">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait IpAddr {
    fn display(&amp;self);
}

struct V4(String);
impl IpAddr for V4 {
    fn display(&amp;self) {
        println!(&quot;ipv4: {:?}&quot;,self.0)
    }
}
struct V6(String);
impl IpAddr for V6 {
    fn display(&amp;self) {
        println!(&quot;ipv6: {:?}&quot;,self.0)
    }
}

fn main() {
    let v: = vec![
        Box::new(V4(&quot;127.0.0.1&quot;.to_string())),
        Box::new(V6(&quot;::1&quot;.to_string())),
    ];

    for ip in v {
        ip.display();
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="basic-operations-1"><a class="header" href="#basic-operations-1">Basic Operations</a></h3>
<ol>
<li></li>
</ol>
<p>Types inside HashMap need to be homogenous</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::collections::HashMap;
fn main() {
    let mut scores = HashMap::new();
    scores.insert(&quot;Sunface&quot;, 98);
    scores.insert(&quot;Daniel&quot;, 95);
    scores.insert(&quot;Ashley&quot;, 69);
    scores.insert(&quot;Katie&quot;, 58); 
    let score = scores.get(&quot;Sunface&quot;);
    assert_eq!(score, Some(&amp;98)); 
    // This returns an Option with reference because, we do not
    // want to get clone or remove the value present at that index.
    // Use get_mut() if you want that or just do last() to get element at the last index.

    if scores.contains_key(&quot;Daniel&quot;) {
        let score = scores[&quot;Daniel&quot;];
        assert_eq!(score, Some(95));
        scores.remove(&quot;Daniel&quot;);
    }

    assert_eq!(scores.len(), 3);

    for (name, score) in scores {
        println!(&quot;The score of {} is {}&quot;, name, score)
    }
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::collections::HashMap;
fn main() {
    let teams = [
        (&quot;Chinese Team&quot;, 100),
        (&quot;American Team&quot;, 10),
        (&quot;France Team&quot;, 50),
    ];

    let mut teams_map1 = HashMap::new();
    for team in &amp;teams {
        teams_map1.insert(team.0, team.1);
    }

    let mut teams_map2: HashMap&lt;_,_&gt; = teams.into_iter().collect();

    assert_eq!(teams_map1, teams_map2);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::collections::HashMap;
fn main() {
    let mut player_stats = HashMap::new();

    player_stats.entry(&quot;health&quot;).or_insert(100);

    assert_eq!(player_stats[&quot;health&quot;], 100);

    player_stats.entry(&quot;health&quot;).or_insert_with(random_stat_buff);
    assert_eq!(player_stats[&quot;health&quot;], 100);

    let health = player_stats.entry(&quot;health&quot;).or_insert(50);
    assert_eq!(health, &amp;100);
    *health -= 50;
    assert_eq!(*health, 50);

    println!(&quot;Success!&quot;)
}

fn random_stat_buff() -&gt; u8 { 42 }
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::collections::HashMap;

#[derive(Debug, Hash, Eq, PartialEq)]
struct Viking {
    name: String,
    country: String,
}

impl Viking {
    fn new(name: &amp;str, country: &amp;str) -&gt; Viking {
        Viking {
            name: name.to_string(),
            country: country.to_string(),
        }
    }
}

fn main() {
    let vikings = HashMap::from([
        (Viking::new(&quot;Einar&quot;, &quot;Norway&quot;), 25),
        (Viking::new(&quot;Olaf&quot;, &quot;Denmark&quot;), 24),
        (Viking::new(&quot;Harald&quot;, &quot;Iceland&quot;), 12),
    ]);

    for (viking, health) in &amp;vikings {
        println!(&quot;{:?} has {} hp&quot;, viking, health);
    }
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::collections::HashMap;
fn main() {
  let v1 = 10;
  let mut m1 = HashMap::new();
  m1.insert(v1, v1);
  println!(&quot;v1 is still usable after inserting to hashmap : {}&quot;, v1);

  let v2 = &quot;hello&quot;;
  let mut m2 = HashMap::new();
  m2.insert(v2, v1);
    
  assert_eq!(v2, &quot;hello&quot;);

  println!(&quot;Success!&quot;)
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-and-borrowing-1"><a class="header" href="#ownership-and-borrowing-1">Ownership and Borrowing</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://std.rs">Standary library</a></li>
<li>ÁÆÄ‰Ωì‰∏≠Êñá: <a href="https://course.rs/basic/converse.html">RustËØ≠Ë®ÄÂú£Áªè - ÊâÄÊúâÊùÉ‰∏éÂÄüÁî®</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let decimal = 97.123_f32;

    let integer: u8 = decimal as u8;

    let c1: char = decimal as u8 as char;
    // why can't rust cut the middle part? Just seems redundant to write that.
    
    let c2 = integer as char;

    assert_eq!(integer, 'b' as u8);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#![allow(overflwing_literals)]
fn main() {
    assert_eq!(u8::MAX, 255);
    let v = 1000 as u8;

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    assert_eq!(1000 as u16, 1000);

    assert_eq!(1000 as u8, 232);

    println!(&quot;1000 mod 256 is : {}&quot;, 1000 % 256);

    assert_eq!(-1_i8 as u8, 255);
    
    assert_eq!(300.1_f32 as u8, 255);
    assert_eq!(-100.1_f32 as u8, 0);
    

    unsafe {
        println!(&quot;300.0 is {}&quot;, 300.0_f32.to_int_unchecked::&lt;u8&gt;());
        println!(&quot;-100.0 as u8 is {}&quot;, (-100.0_f32).to_int_unchecked::&lt;u8&gt;());
        println!(&quot;nan as u8 is {}&quot;, f32::NAN.to_int_unchecked::&lt;u8&gt;());
    }
}
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let mut values: [i32; 2] = [1, 2];
    let p1: *mut i32 = values.as_mut_ptr();
    let first_address: usize = p1 as usize; 
    let second_address = first_address + 4; 
    let p2 = second_address as &amp;mut ptr; 
    unsafe {
       *p2 += 1; 
    }
     
    assert_eq!(values[1], 3);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let arr :[u64; 13] = [0; 13];
    assert_eq!(std::mem::size_of_val(&amp;arr), 8 * 13);
    let a: *const [u64] = &amp;arr;
    let b = a as *const [u8];
    unsafe {
        assert_eq!(std::mem::size_of_val(&amp;*b), 13)
    }

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li></li>
</ol>
<p>This does not work in the website code box. Not sure if it would work in actual code.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">impl From&lt;bool&gt; for i32 {
    #[inline]
    fn from(b: bool) -&gt; i32 {
        if b {1} else {0}
    }
}

fn main() {
    let i1:i32 = false.into();
    let i2:i32 = i32::from(false);  
    assert_eq!(i1, i2);
    assert_eq!(i1, 0);

    let i3: i32 = 'a'.into();

    let s: String = String::from('a'); // already implemented

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    #[inline]
    fn from(num: i32) -&gt; Number {
        Number { value: num }
    }
}

fn main() {
    let num = Number::from(30);
    assert_eq!(num.value, 30);

    let num: Number = 30.into();
    assert_eq!(num.value, 30);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::fs;
use std::io;
use std::num;

enum CliError {
    IoError(io::Error),
    ParseError(num::ParseIntError),
}

impl From&lt;io::Error&gt; for CliError {
    fn from(error: io::Error) -&gt; CliError {
        CliError::IoError(error)
    }
}

impl From&lt;num::ParseIntError&gt; for CliError {
    fn from(error: num::ParseIntError) -&gt; CliError {
        CliError::ParseError(error)
    }
}

fn open_and_parse_file(file_name: &amp;str) -&gt; Result&lt;i32, CliError&gt; {
    let contents = fs::read_to_string(&amp;file_name)?;
    let num: i32 = contents.trim().parse()?;
    Ok(num)
}

fn main() {
    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let n: i16 = 256;

    let n: u8 = match n.try_into() {
        Ok(n) =&gt; n,
        Err(e) =&gt; {
            println!(&quot;there is an error when converting: {:?}, but we catch it&quot;, e.to_string());
            0
        }
    };

    assert_eq!(n, 0);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug, PartialEq)]
struct EvenNum(i32);

impl TryFrom&lt;i32&gt; for EvenNum {
    type Error = ();

    fn try_from(value: i32) -&gt; Result&lt;Self, Self::Error&gt; {
        if value % 2 == 0 {
            Ok(EvenNum(value))
        } else {
            Err(())
        }
    }
}

fn main() {
    assert_eq!(EvenNum::try_from(8), Ok(EvenNum(8)));
    assert_eq!(EvenNum::try_from(5), Err(()));

    let result: Result&lt;EvenNum, ()&gt; = 8i32.try_into();
    assert_eq!(result, Ok(EvenNum(8)));
    let result: Result&lt;EvenNum, ()&gt; = 5i32.try_into();
    assert_eq!(result, Err(()));

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;[{}, {}]&quot;, self.x, self.y)
    }
}

fn main() {
    let origin = Point { x: 0, y: 0 };
    assert_eq!(origin.to_string(), &quot;The point is [0, 0]&quot;);
    assert_eq!(format!(&quot;the point is {origin}&quot;), &quot;The point is [0, 0]&quot;);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::str::FromStr;
fn main() {
    let parsed: i32 = &quot;5&quot;.parse().unwrap();
    let turbo_parsed = &quot;10&quot;.parse::&lt;i32&gt;().unwrap();
    let from_str = i32::from_str(&quot;20&quot;).unwrap();
    let sum = parsed + turbo_parsed + from_str;
    assert_eq!(sum, 35);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::str::FromStr;
use std::num::ParseIntError;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32
}

impl FromStr for Point {
    type Err = ParseIntError;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        let coords: Vec&lt;&amp;str&gt; = s.trim_matches(|p| p == '{' || p == '}' )
                                 .split(',')
                                 .collect();

        let x_fromstr = coords[0].parse::&lt;i32&gt;()?;
        let y_fromstr = coords[1].parse::&lt;i32&gt;()?;

        Ok(Point { x: x_fromstr, y: y_fromstr })
    }
}
fn main() {
    let p = Point::from_str(&quot;{3, 4}&quot;);
    // &quot;{3, 4}&quot;.parse::&lt;Point&gt;()
    assert_eq!(p.unwrap(), Point{ x: 3, y: 4} );

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-and-panic"><a class="header" href="#result-and-panic">Result and panic</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">Rust Book 9.1, 9.2</a></li>
<li>ÁÆÄ‰Ωì‰∏≠Êñá: <a href="https://course.rs/basic/result-error/intro.html">RustËØ≠Ë®ÄÂú£Áªè - ËøîÂõûÂÄºÂíåÈîôËØØÂ§ÑÁêÜ</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn drink(beverage: &amp;str) {
    if beverage == &quot;lemonade&quot; {
        println!(&quot;Success!&quot;);
        
        panic!(&quot;Totally uneccessary&quot;); // You shouldn't be using panic this way though.
     }

    println!(&quot;Excercise Failed if printing out this line!&quot;);
}

fn main() {
    drink(&quot;lemonade&quot;);

    println!(&quot;Excercise Failed if printing out this line!&quot;);
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    assert_eq!(&quot;abc&quot;.as_bytes(), [96, 97, 98]);

    let v = vec![1, 2, 3];
    let ele = v[2];
    let ele = v.get(2).unwrap();

    let v = production_rate_per_hour(2);

    divide(15, 1);

    println!(&quot;Success!&quot;)
}

fn divide(x:u8, y:u8) {
    println!(&quot;{}&quot;, x / y)
}

fn production_rate_per_hour(speed: u8) -&gt; f64 {
    let cph: u8 = 21;
    match speed {
        1..=4 =&gt; (speed * cph) as f64,
        5..=8 =&gt; (speed * cph) as f64 * 0.9,
        9..=10 =&gt; (speed * cph) as f64 * 0.77,
        _ =&gt; 0 as f64,
    }
}

pub fn working_items_per_minute(speed: u8) -&gt; u32 {
    (production_rate_per_hour(speed) / 60 as f64) as u32
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><code class="language-shell">$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `[97, 98, 99]`,
 right: `[96, 97, 98]`', src/main.rs:3:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/std/src/panicking.rs:498:5
   1: core::panicking::panic_fmt
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/core/src/panicking.rs:116:14
   2: core::panicking::assert_failed_inner
   3: core::panicking::assert_failed
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/core/src/panicking.rs:154:5
   4: study_cargo::main
             at ./src/main.rs:3:5
   5: core::ops::function::FnOnce::call_once
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/core/src/ops/function.rs:227:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li></li>
</ol>
<p>It is not recommended to use unwrap() if you're unsure about the result. Check if pragmatically the expression is not going to give the unwanted option. In which case unwrap() can be used without an issue. Otherwise it is best to avoid using it and instead use pattern-matching.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::num::ParseIntError;

fn multiply(n1_str: &amp;str,
            n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let n1 = n1_str.parse::&lt;i32&gt;();
    let n2 = n2_str.parse::&lt;i32&gt;();
    Ok(n1.unwrap() * n2.unwrap())
}

fn main() {
    let result = multiply(&quot;10&quot;, &quot;2&quot;);
    assert_eq!(result, Ok(20));

    let result = multiply(&quot;4&quot;, &quot;2&quot;);
    assert_eq!(result.unwrap(), 8);
    
    
    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::num::ParseIntError;

fn multiply(n1_str: &amp;str,
            n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let n1 = n1_str.parse::&lt;i32&gt;()?;
    let n2 = n2_str.parse::&lt;132&gt;()?;
    
    // Use this in main when you need to STOP the program because you cannot proceed.
    // In other words, if Error result is an error rather than an exception then it is allowed.
    // In that case, it is okay to use &quot;?&quot; in main. 
    // 
    // This is how to use the above function if the error result is an exception:
    // 
    // if let Ok(result) = multiply(&quot;10&quot;, &quot;2&quot;) {
    //      ... to handle result.
    // } else {
    //      ... to handle error.
    // }
    // 
    // This is essentailly try-catch for rust.

    Ok(n1 * n2)
}

fn main() {
    assert_eq!(multiply(&quot;3&quot;, &quot;4&quot;).unwrap(), 12);
    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::fs::File;
use std::io::{self, Read};

fn read_file1() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);
    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();
    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}

fn read_file2() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}

fn main() {
    assert_eq!(read_file1().unwrap_err().to_string(), read_file2().unwrap_err().to_string());
    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

fn add_two(n_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
   n_str.parse::&lt;i32&gt;().map(|x| x + 2);
}

fn main() {
    assert_eq!(add_two(&quot;4&quot;).unwrap(), 6);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    match n1_str.parse::&lt;i32&gt;() {
        Ok(n1)  =&gt; {
            match n2_str.parse::&lt;i32&gt;() {
                Ok(n2)  =&gt; {
                    Ok(n1 * n2)
                },
                Err(e) =&gt; Err(e),
            }
        },
        Err(e) =&gt; Err(e),
    }
}

fn multiply1(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    n1_str.parse::&lt;i32&gt;().and_then(|n1| {
        n2_str.parse::&lt;i32&gt;()?.map(|n2| n1 * n2)
    })
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    // This still presents a reasonable answer.
    let twenty = multiply1(&quot;10&quot;, &quot;2&quot;);
    print(twenty);

    // The following now provides a much more helpful error message.
    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    print(tt);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="6">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

type Res&lt;T&gt; = Result&lt;T, ParseIntError&gt;;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Res&lt;i32&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

fn print(result: Res&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crate-and-module"><a class="header" href="#crate-and-module">Crate and module</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">Rust Book Chapter 7</a></li>
<li>ÁÆÄ‰Ωì‰∏≠Êñá: <a href="https://course.rs/basic/crate-module/intro.html">RustËØ≠Ë®ÄÂú£Áªè - ÂåÖÂíåÊ®°Âùó</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li>cargo new --bin hello-package</li>
</ol>
<pre><code class="language-shell">.
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ main.rs

1 directory, 2 files
</code></pre>
<pre><code class="language-toml"># in Cargo.toml
[package]
name = &quot;hello-package&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
</code></pre>
<ol start="2">
<li>cargo new --lib hello-package1</li>
</ol>
<pre><code class="language-shell">.
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ lib.rs

1 directory, 2 files
</code></pre>
<pre><code class="language-toml"># in Cargo.toml
[package]
name = &quot;hello-package1&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
</code></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Q: Whats the difference between package 1# and 2# ?
// A: crate 1 is a binary. It is used for binary executable code.
// The entry point for the crate is from main.
// crate 2 is a library crate. It is used for libraries.
// lib.rs acts as an entry point ABI for the library. 
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Q: Whats the name of the library crate in package `hello-package1`?
// A: hello-package1
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<p>I've been losing my mind over this. How the hell do you type '‚îÄ', '‚îú' and '‚îÇ'? Why is this so hard to do?</p>
<pre><code class="language-shell editable">.
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.rs
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ lib.rs

</code></pre>
<ol start="6">
<li></li>
</ol>
<pre><code class="language-shell editable">.
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ main.rs
‚îÇ   ‚îú‚îÄ‚îÄ lib.rs
‚îÇ   ‚îî‚îÄ‚îÄ bin
‚îÇ       ‚îî‚îÄ‚îÄ main1.rs
‚îÇ       ‚îî‚îÄ‚îÄ main2.rs
‚îú‚îÄ‚îÄ tests 
‚îÇ   ‚îî‚îÄ‚îÄ some_integration_tests.rs
‚îú‚îÄ‚îÄ benches 
‚îÇ   ‚îî‚îÄ‚îÄ simple_bench.rs
‚îî‚îÄ‚îÄ examples 
    ‚îî‚îÄ‚îÄ simple_example.rs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li></li>
</ol>
<pre><code class="language-shell">library crate root
 ‚îî‚îÄ‚îÄ front_of_house
     ‚îú‚îÄ‚îÄ hosting
     ‚îÇ   ‚îú‚îÄ‚îÄ add_to_waitlist
     ‚îÇ   ‚îî‚îÄ‚îÄ seat_at_table
     ‚îî‚îÄ‚îÄ serving
         ‚îú‚îÄ‚îÄ take_order
         ‚îú‚îÄ‚îÄ serve_order
         ‚îú‚îÄ‚îÄ take_payment
         ‚îî‚îÄ‚îÄ complain
</code></pre>
<blockquote>
<p>current file: lib.rs</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
        
        fn seat_at_table() {}
    }
    
    mod serving {
        fn take_order() {}
        
        fn serve_order() {}

        fn take_payment() {}

        fn complain() {}
    }
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<blockquote>
<p>current file: lib.rs</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    mod hosting {
        fn add_to_watlist() {}
        
        fn seat_at_table() {}
    }
}

pub fn eat_at_restaurant() {
    crate::front_of_house::hosting::add_to_waitlist();

    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<ol start="3">
<li></li>
</ol>
<blockquote>
<p>current file: lib.rs</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::front_of_house::serving::serve_order();
        // crate::front_of_house::serving::serve_order();
    }

    fn cook_order() {}
}
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><code class="language-shell">.
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ back_of_house.rs
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ front_of_house
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hosting.rs
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ mod.rs
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ serving.rs
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ lib.rs
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ main.rs
</code></pre>
<blockquote>
<p>current file: lib.rs</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">mod front_of_house;
mod back_of_house;
pub fn eat_at_restaurant() -&gt; String {
    front_of_house::hosting::add_to_waitlist();

    back_of_house::cook_order();

    String::from(&quot;mamma mia!&quot;)
}
</code></pre></pre>
<blockquote>
<p>current file: src/back_of_house.rs</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">use crate::front_of_house;

pub fn fix_incorrect_order() {
    cook_order();
    crate::front_of_house::serving::serve_order();
}

fn cook_order() {}
</code></pre></pre>
<blockquote>
<p>current file: src/back_of_house/mod.rs</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub mod hosting;
pub mod serving;
</code></pre></pre>
<blockquote>
<p>current file: src/front_of_house/hosting.rs</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn add_to_waitlist() {
    // add to a vector/struct with vector of waitilist.
}

fn seat_at_table() {
    String::from(&quot;sit down please&quot;)
}

</code></pre></pre>
<blockquote>
<p>current file: src/front_of_house/serving.rs</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub fn take_order() {}

pub fn serve_order() {}

pub fn take_payment() {}

fn complain() -&gt; String {
    String::from(&quot;I spat on his food&quot;)
}

</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<blockquote>
<p>current file: src/main.rs</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">mod front_of_house;

fn main() {
    assert_eq!(front_of_house::hosting::seat_at_table(), &quot;sit down please&quot;);
    assert_eq!(hello_package::eat_at_restaurant(), &quot;yummy yummy!&quot;);
    
    // Oops, a customer snuck to the back and overheard!
    assert_eq!(front_of_house::serving::complain(), &quot;I spat on his food&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Result;
use std::io::Result as IoTypeResult;

fn main() {}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::collections::*;
// Not recommended sometimes.
// No need to import modules that are not going to be used.
// Keep your code clean.

fn main() {
    let _c1:HashMap&lt;&amp;str, i32&gt; = HashMap::new();
    let mut c2 = BTreeMap::new();
    c2.insert(1, &quot;a&quot;);
    let _c3: HashSet&lt;i32&gt; = HashSet::new();
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::{HashMap, BTreeMap, HashSet};
// This is the recommended way to import.
// Not only does this avoid importing unnecessary modules, it is also understandable.
// This way anyone reading the code can know what was imported from the modules.

fn main() {
    let _c1:HashMap&lt;&amp;str, i32&gt; = HashMap::new();
    let mut c2 = BTreeMap::new();
    c2.insert(1, &quot;a&quot;);
    let _c3: HashSet&lt;i32&gt; = HashSet::new();
}

</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Add this line in lib.rs
// pub use crate::front_of_house::hosting;
fn main() {
    assert_eq!(hello_package::hosting::seat_at_table(), &quot;sit down please&quot;);
    assert_eq!(hello_package::eat_at_restaurant(),&quot;yummy yummy!&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li></li>
</ol>
<p>The rest of the excercise is in the project file.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
//    todo!();
//    unimplemented!();

    assert_eq!(6, 5 + /* 3 + 2 + */ 1 )
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatted-output"><a class="header" href="#formatted-output">Formatted Output</a></h1>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s1 = &quot;hello&quot;;
    let s = format!(&quot;{}, world!&quot;, s1);
    assert_eq!(s, &quot;hello, world!&quot;);
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    print!(&quot;hello world, &quot;);
    println!(&quot;I am&quot;);
    print!(&quot;Sunface!\n&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Structure(i32);

fn main() {
    println!(&quot;{} months in a year.&quot;, 12);

    println!(&quot;Now {:?} will print!&quot;, Structure(3));
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Person {
    name: String,
    age: u8
}

fn main() {
    let person = Person { name:  &quot;Sunface&quot;.to_string(), age: 18 };
    println!(&quot;{:#?}&quot;, person);
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt;

#[derive(Debug)]
struct Structure(i32);

#[derive(Debug)]
struct Deep(Structure);

impl fmt::Debug for Structure {
    fn fmt(&amp;self, f: fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;{:?}&quot;, self.0)
    }
}

impl fmt::Debug for Deep {
    fn fmt(&amp;self, f: fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
       write!(f, &quot;{:?}&quot;, self.0) 
    }
}

fn main() {    
    println!(&quot;Now {:?} will print!&quot;, Deep(Structure(7)));
}

</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::fmt;

struct Point2D {
    x: f64,
    y: f64,
}

impl fmt::Display for Point2D {
    fn fmt(&amp;self, f: fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;Display: {} + {}i&quot;, self.0, self.1)
    }
}

impl fmt::Debug for Point2D {
    fn fmt(&amp;self, f: fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;Debug: Complex{ real: {}, imag: {} }&quot;, self.0, self.1)
}

fn main() {
    let point = Point2D { x: 3.3, y: 7.2 };
    assert_eq!(format!(&quot;{}&quot;,point), &quot;Display: 3.3 + 7.2i&quot;);
    assert_eq!(format!(&quot;{:?}&quot;,point), &quot;Debug: Complex { real: 3.3, imag: 7.2 }&quot;);
    
    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt; 

struct List(Vec&lt;i32&gt;);

impl fmt::Display for List {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let vec = &amp;self.0;

        write!(f, &quot;[&quot;)?;

        for (count, v) in vec.iter().enumerate() {
            if count != 0 { write!(f, &quot;, &quot;)?; }
            write!(f, &quot;{}: {}&quot;, count, v)?;
        }

        write!(f, &quot;]&quot;)
    }
}

fn main() {
    let v = List(vec![1, 2, 3]);
    assert_eq!(format!(&quot;{}&quot;,v), &quot;[0: 1, 1: 2, 2: 3]&quot;);
    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust edtiable edition2021">fn main() {
    println!(&quot;{0}, this is {1}. {1}, this is {0}&quot;, &quot;Alice&quot;, &quot;Bob&quot;);
    assert_eq!(format!(&quot;{1}{0}&quot;, 1, 2), &quot;21&quot;);
    assert_eq!(format!(&quot;{1}{0}{0}{1}&quot;, 1, 2), &quot;2112&quot;);
    println!(&quot;Success!&quot;);
}
</code></pre></pre>
<ol start="2">
<li></li>
</ol>
<p>Named argument must be placed after other arguments</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!(&quot;{argument}&quot;, argument = &quot;test&quot;);

    assert_eq!(format!(&quot;{name}{}&quot;, 1, name = 2), &quot;21&quot;);
    assert_eq!(format!(&quot;{a} {c} {b}&quot;,a = &quot;a&quot;, b = 'b', c = 3 ), &quot;a 3 b&quot;);

    println!(&quot;{abc} {0}&quot;, 2, abc = &quot;def&quot;);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="3">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!(&quot;Hello {:5}!&quot;, &quot;x&quot;); 
    println!(&quot;Hello {:1$}!&quot;, &quot;x&quot;, 5);

    assert_eq!(format!(&quot;Hello {1:0$}!&quot;, 5, &quot;x&quot;), &quot;Hello x    !&quot;);
    assert_eq!(format!(&quot;Hello {:width$}!&quot;, &quot;x&quot;, width = 5), &quot;Hello x    !&quot;);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="4">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!(&quot;Hello {:&lt;5}!&quot;, &quot;x&quot;);
    assert_eq!(format!(&quot;Hello {:&gt;5}!&quot;, &quot;x&quot;), &quot;Hello     x!&quot;);
    assert_eq!(format!(&quot;Hello {:^5}!&quot;, &quot;x&quot;), &quot;Hello   x  !&quot;);

    assert_eq!(format!(&quot;Hello {:&amp;&lt;5}!&quot;, &quot;x&quot;), &quot;Hello x&amp;&amp;&amp;&amp;!&quot;);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="5">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!(&quot;Hello {:5}!&quot;, 5);
    println!(&quot;Hello {:+}!&quot;, 5);
    println!(&quot;Hello {:05}!&quot;, 5);
    println!(&quot;Hello {:05}!&quot;, -5);

    assert!(format!(&quot;{number:0&gt;width$}&quot;, number=1, width=6) == &quot;000001&quot;);
    
    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="6">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let v = 3.1415926;

    println!(&quot;{:.1$}&quot;, v, 4); 

    assert_eq!(format!(&quot;:.2&quot;, v), &quot;3.14&quot;);
    assert_eq!(format!(&quot;:+2&quot;, v), &quot;+3.14&quot;);
    assert_eq!(format!(&quot;:.0&quot;, v), &quot;3&quot;);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="7">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = &quot;Hello, world!&quot;;

    println!(&quot;{0:.5}&quot;, s);

    assert_eq!(format!(&quot;Hello {1:.0$}!&quot;, 3, &quot;abcdefg&quot;), &quot;Hello abc!&quot;);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="8">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    assert_eq!(format!(&quot;#b&quot;, 27), &quot;0b11011&quot;); // binary
    assert_eq!(format!(&quot;#o&quot;, 27), &quot;0o33&quot;); // octal
    assert_eq!(format!(&quot;#x&quot;, 27), &quot;0x1b&quot;); // Hex
    assert_eq!(format!(&quot;#X&quot;, 27), &quot;0x1B&quot;); // Hex but uppercase

    println!(&quot;{:x}!&quot;, 27);

    println!(&quot;{:#010b}&quot;, 27);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="9">
<li></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn get_person() -&gt; String {
    String::from(&quot;sunface&quot;)
}

fn get_format() -&gt; (usize, usize) {
    (4, 1)
}


fn main() {
    let person = get_person();
    println!(&quot;Hello, {person}!&quot;);

    let (width, precision) = get_format();
    let scores = [(&quot;sunface&quot;, 99.12), (&quot;jack&quot;, 60.34)];
    for (name, score) in scores {
        println!(&quot;{name}: {score:width$.prescision$}&quot;);
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-programing"><a class="header" href="#functional-programing">Functional programing</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch13-00-functional-features.html">Rust Book 13</a></li>
<li>ÁÆÄ‰Ωì‰∏≠Êñá: <a href="https://course.rs/advance/functional-programing/intro.html">RustËØ≠Ë®ÄÂú£Áªè - ÂáΩÊï∞ÂºèÁºñÁ®ãÔºöÈó≠ÂåÖÂíåËø≠‰ª£Âô®</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>1„ÄÅ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let color = String::from(&quot;green&quot;);

    let print = || println!(&quot;`color`: {}&quot;, color); // no need to move

    print();
    print();

    println!(&quot;{}&quot;,color);
}
</code></pre></pre>
<p>2„ÄÅ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut count = 0;

    let mut inc = move || {
        count += 1;
        println!(&quot;`count`: {}&quot;, count);
    };

    inc();


    let _reborrow = &amp;count; 

    inc();

    let _count_reborrowed = &amp;mut count; 

    assert_eq!(count, 0);
}
</code></pre></pre>
<p>3„ÄÅ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 1.
fn main() {
     let movable = Box::new(3);

     let consume = || {
         println!(&quot;`movable`: {:?}&quot;, movable);
         take(movable);
     };

     consume();
    // consume(); already moved
}

fn take&lt;T&gt;(_v: T) {}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">// 2.
fn main() {
     let movable = Box::new(3);

     let consume = move || {
         println!(&quot;`movable`: {:?}&quot;, movable);
         take(&amp;movable); // by reference only.
     };

     consume();
     consume();
}

fn take&lt;T&gt;(_v:&amp;T) {}
</code></pre></pre>
<p>4„ÄÅ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let example_closure = |x| x;

    let s = example_closure(String::from(&quot;hello&quot;));

    let n = example_closure(String::from(&quot;5&quot;.to_owned()));
}
</code></pre></pre>
<p>5„ÄÅ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn fn_once&lt;F&gt;(func: F)
where
    F: Fn /*Once*/ (usize) -&gt; bool /* + Copy  also another way*/,
{
    println!(&quot;{}&quot;, func(3));
    println!(&quot;{}&quot;, func(4));
}

fn main() {
    let x = vec![1, 2, 3];
    fn_once(|z|{z == x.len()})
}
</code></pre></pre>
<p>6„ÄÅ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s = String::new();

    let update_string = |str| s.push_str(str);

    exec(update_string);

    println!(&quot;{:?}&quot;,s);
}

fn exec&lt;'a, F: FnMut(&amp;'a str)&gt;(mut f: F)  {
    f(&quot;hello&quot;)
}
</code></pre></pre>
<p>7„ÄÅ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn apply&lt;F&gt;(f: F) where
    F: FnOnce() {

    f();
}

fn apply_to_3&lt;F&gt;(f: F) -&gt; i32 where
    F: Fn(i32) -&gt; i32 {

    f(3)
}

fn main() {
    use std::mem;

    let greeting = &quot;hello&quot;;
    let mut farewell = &quot;goodbye&quot;.to_owned();

    let diary = || {
        println!(&quot;I said {}.&quot;, greeting);

        farewell.push_str(&quot;!!!&quot;);
        println!(&quot;Then I screamed {}.&quot;, farewell);
        println!(&quot;Now I can sleep. zzzzz&quot;);

        mem::drop(farewell);
    };

    apply(diary);

    let double = |x| 2 * x;

    println!(&quot;3 doubled: {}&quot;, apply_to_3(double));
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s = String::new();

    let update_string = |str| -&gt; String { s.push_str(str); s };

    exec(update_string);
}

fn exec&lt;'a, F: FnOnce(&amp;'a str) -&gt; String&gt;(mut f: F)  {
    f(&quot;hello&quot;);
}
</code></pre></pre>
<p>8„ÄÅ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s = String::new();

    let update_string = |str| -&gt; String {s.push_str(str); s };

    exec(update_string);
}

fn exec&lt;'a, F: FnOnce(&amp;'a str) -&gt; String&gt;(mut f: F) {
    f(&quot;hello&quot;);
}
</code></pre></pre>
<p>9„ÄÅ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn call_me&lt;F: Fn()&gt;(f: F) { // Using generics
    f();
}

fn function() {
    println!(&quot;I'm a function!&quot;);
}

fn main() {
    let closure = || println!(&quot;I'm a closure!&quot;);

    call_me(closure);
    call_me(function);
}
</code></pre></pre>
<p>10„ÄÅ
The reason we use a Box here is because, we do not know the size of a trait at compile time. Hence, we use Box which is a Heap allocation. Also, the useof &quot;dyn&quot; keyword. Basically, it is used to distinguish and address dynamic dispatch when you're using traits as a type rather than interface. </p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn create_fn() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    let num = 5;

    Box::new(move |x| x + num)
}


fn main() {
    let fn_plain = create_fn();
    fn_plain(1);
}
</code></pre></pre>
<p>11„ÄÅ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn factory(x:i32) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {

    let num = 5;

    if x &gt; 1{
        Box::new(move |x| x + num)
    } else {
        Box::new(move |x| x + num) // Same here I guess
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>1„ÄÅ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let arr = [0; 10];
    for i in arr {
        println!(&quot;{}&quot;,i)
    }
}
</code></pre></pre>
<p>2„ÄÅ</p>
<pre><pre class="playground"><code class="language-rust editble edition2021">fn main() {
    let mut v = Vec::new();
    for n in 1..101 {
       v.push(n);
    }

    assert_eq!(v.len(), 100);
}
</code></pre></pre>
<p>3„ÄÅ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 1.
fn main() {
    let v = vec![1, 2];
    
    let v1 = v.into_iter(); // Moves the borrow.

    assert_eq!(v1.next(), Some(1));
    assert_eq!(v1.next(), Some(2));
    assert_eq!(v1.next(), None);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 2.
fn main() {
    let v = vec![1, 2];
    
    let v1 = v.iter(); // Doesn't move the borrow.

    assert_eq!(v1.next(), Some(1));
    assert_eq!(v1.next(), Some(2));
    assert_eq!(v1.next(), None);
}
</code></pre></pre>
<p>4„ÄÅ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let arr = vec![0; 10];
    for i in arr.iter() { // Create iterator
        println!(&quot;{}&quot;, i)
    }

    println!(&quot;{:?}&quot;,arr);
}
</code></pre></pre>
<p>5„ÄÅ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.iter_mut() { // Mutable iterator
        *name = match name {
            &amp;mut &quot;Ferris&quot; =&gt; &quot;There is a rustacean among us!&quot;,
            _ =&gt; &quot;Hello&quot;,
        }
    }

    println!(&quot;names: {:?}&quot;, names);
}
</code></pre></pre>
<p>6„ÄÅ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut values = vec![1, 2, 3];
    let mut values_iter = values.iter_mut();

    if let Some(v) = values_iter.into_next() {
       *v = 0;
    }

    assert_eq!(values, vec![0, 2, 3]);
}
</code></pre></pre>
<p>7„ÄÅ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Fibonacci {
    curr: u32,
    next: u32,
}

impl Iterator for Fibonacci {
    type Item = u32;
    
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let next = self.curr + self.next;

        self.curr = self.next;
        self.next = next;

        Some(self.curr)
    }
}

fn fibonacci() -&gt; Fibonacci {
    Fibonacci { curr: 0, next: 1 }
}

fn main() {
    let mut fib = fibonacci();
    assert_eq!(fib.next(), Some(1));
    assert_eq!(fib.next(), Some(1));
    assert_eq!(fib.next(), Some(2));
    assert_eq!(fib.next(), Some(3));
    assert_eq!(fib.next(), Some(5));
}
</code></pre></pre>
<p>8„ÄÅ</p>
<pre><pre class="playground"><code class="language-rust edtiable edition2021">fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total = v1_iter.sum();

    assert_eq!(total, 6);

    println!(&quot;{:?}, {:?}&quot;,v1, v1_iter);
}
</code></pre></pre>
<p>9„ÄÅ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::collections::HashMap;
fn main() {
    let names = [(&quot;sunface&quot;,18), (&quot;sunfei&quot;,18)];
    let folks: HashMap&lt;_, _&gt; = names.into_iter().collect();

    println!(&quot;{:?}&quot;,folks);

    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;i32&gt; = v1.into_iter().collect(); // Moved borrow

    assert_eq!(v2, vec![1, 2, 3]);
}
</code></pre></pre>
<p>10„ÄÅ</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2 = v1.iter().map(|x| x + 1).collect::&lt;i32&gt;();

    assert_eq!(v2, vec![2, 3, 4]);
}
</code></pre></pre>
<p>11„ÄÅ</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::HashMap;
fn main() {
    let names = [&quot;sunface&quot;, &quot;sunfei&quot;];
    let ages = [18, 18];
    let folks: HashMap&lt;_, _&gt; = names.into_iter().zip(ages.into_iter()).collect();

    println!(&quot;{:?}&quot;,folks);
}
</code></pre></pre>
<p>12„ÄÅ </p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|x| is_shoe_size(&amp;x, &amp;shoe_size)).collect()
}

// Being extra for no reason.
fn is_shoe_size(x: &amp;Vec&lt;Shoe&gt;, shoe_size: &amp;u32) -&gt; bool {
    *x.shoe == *shoe_size 
}

fn main() {
    let shoes = vec![
        Shoe {
            size: 10,
            style: String::from(&quot;sneaker&quot;),
        },
        Shoe {
            size: 13,
            style: String::from(&quot;sandal&quot;),
        },
        Shoe {
            size: 10,
            style: String::from(&quot;boot&quot;),
        },
    ];

    let in_my_size = shoes_in_size(shoes, 10);

    assert_eq!(
        in_my_size,
        vec![
            Shoe {
                size: 10,
                style: String::from(&quot;sneaker&quot;)
            },
            Shoe {
                size: 10,
                style: String::from(&quot;boot&quot;)
            },
        ]
    );
}
</code></pre></pre>

                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript" charset="utf-8">
        var pagePath = "print.md"
        </script>


        <!-- Custom JS scripts -->
        <script type="text/javascript" src="assets/custom3.js"></script>
        <script type="text/javascript" src="assets/lang.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>